<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=这个人很懒，什么也没留下><meta name=author content=jsyPrajna><link href=https://github.com/jsyPrajna/Notes/MFC/MFC%20notes/ rel=canonical><link rel=icon href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.5.3, mkdocs-material-9.4.2"><title>MFC随笔记录 - 姜某的笔记</title><link rel=stylesheet href=../../assets/stylesheets/main.d451bc0e.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.a5377069.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Noto+Sans:300,300i,400,400i,700,700i%7CSource+Code+Pro:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Noto Sans";--md-code-font:"Source Code Pro"}</style><link rel=stylesheet href=../../static/css/extra.css><link rel=stylesheet href=../../static/css/main.bf3dc0a9.min.css><script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=teal data-md-color-accent=red> <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#mfc class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=页眉> <a href=../.. title=姜某的笔记 class="md-header__button md-logo" aria-label=姜某的笔记 data-md-component=logo> <img src=../../static/big-yellow-star.jpg alt=logo> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> 姜某的笔记 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> MFC随笔记录 </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=teal data-md-color-accent=red aria-label="Switch to dark mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_2 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=black data-md-color-accent=green aria-label="Switch to light mode" type=radio name=__palette id=__palette_2> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg> </label> </form> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=查找> <a href=javascript:void(0) class="md-search__icon md-icon" title=分享 aria-label=分享 data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=清空当前内容 aria-label=清空当前内容 tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/jsyPrajna/Notes title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 480 512"><!-- Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg> </div> <div class=md-source__repository> jsyPrajna/Notes </div> </a> </div> </nav> <nav class=md-tabs aria-label=标签 data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../.. class=md-tabs__link> Main </a> </li> <li class=md-tabs__item> <a href=../../C%2B%2B/C%2B%2B%20core%20programming/ class=md-tabs__link> C++ </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=导航栏 data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title=姜某的笔记 class="md-nav__button md-logo" aria-label=姜某的笔记 data-md-component=logo> <img src=../../static/big-yellow-star.jpg alt=logo> </a> 姜某的笔记 </label> <div class=md-nav__source> <a href=https://github.com/jsyPrajna/Notes title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 480 512"><!-- Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg> </div> <div class=md-source__repository> jsyPrajna/Notes </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> <span class=md-ellipsis> Main </span> </a> </li> <li class="md-nav__item md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex> <span class=md-ellipsis> C++ </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> C++ </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../C%2B%2B/C%2B%2B%20core%20programming/ class=md-nav__link> <span class=md-ellipsis> C++核心编程 </span> </a> </li> <li class=md-nav__item> <a href=../../C%2B%2B/C%2B%2B%20improves%20programming/ class=md-nav__link> <span class=md-ellipsis> C++提高编程 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#_1 class=md-nav__link> 基础部分 </a> <nav class=md-nav aria-label=基础部分> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_2 class=md-nav__link> 句柄与对象转换 </a> <nav class=md-nav aria-label=句柄与对象转换> <ul class=md-nav__list> <li class=md-nav__item> <a href=#hwndcwnd class=md-nav__link> HWND与CWnd对象之间的转换： </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> 句柄嫁接与子类化： </a> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> 总结嫁接与子类化： </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_5 class=md-nav__link> 客户区拖动 </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> 定时器使用 </a> </li> <li class=md-nav__item> <a href=#_7 class=md-nav__link> 获取屏幕宽高 </a> </li> <li class=md-nav__item> <a href=#_8 class=md-nav__link> 坐标转换 </a> <nav class=md-nav aria-label=坐标转换> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_9 class=md-nav__link> 获取控件相对客户区的坐标 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_10 class=md-nav__link> 布局控件跟随对话框变化 </a> </li> <li class=md-nav__item> <a href=#create class=md-nav__link> Create创建控件的映射方法 </a> </li> <li class=md-nav__item> <a href=#cimagelist class=md-nav__link> CImageList的使用 </a> </li> <li class=md-nav__item> <a href=#clistctrl class=md-nav__link> CListCtrl单行满满选中 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#gdi class=md-nav__link> 六大GDI绘图对象 </a> <nav class=md-nav aria-label=六大GDI绘图对象> <ul class=md-nav__list> <li class=md-nav__item> <a href=#getbitmapbits class=md-nav__link> GetBitmapBits函数 </a> </li> <li class=md-nav__item> <a href=#_11 class=md-nav__link> 位图贴图流程 </a> <nav class=md-nav aria-label=位图贴图流程> <ul class=md-nav__list> <li class=md-nav__item> <a href=#win32 class=md-nav__link> 位图显示：（win32） </a> </li> <li class=md-nav__item> <a href=#mfc_1 class=md-nav__link> MFC下的位图显示流程： </a> </li> <li class=md-nav__item> <a href=#bitblt class=md-nav__link> BitBlt函数： </a> </li> <li class=md-nav__item> <a href=#stretchblt class=md-nav__link> StretchBlt()拉伸贴图 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_12 class=md-nav__link> 对话框背景后景色的刷新 </a> </li> <li class=md-nav__item> <a href=#_13 class=md-nav__link> 拖动客户区 </a> </li> <li class=md-nav__item> <a href=#_14 class=md-nav__link> 空填充矩形 </a> </li> <li class=md-nav__item> <a href=#crgn class=md-nav__link> CRgn使用示例 </a> <nav class=md-nav aria-label=CRgn使用示例> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_15 class=md-nav__link> 绘制一个圆形的图片 </a> </li> <li class=md-nav__item> <a href=#_16 class=md-nav__link> 绘制一个自定义的窗口 </a> </li> <li class=md-nav__item> <a href=#rgn class=md-nav__link> Rgn合并 </a> </li> <li class=md-nav__item> <a href=#rgn_1 class=md-nav__link> Rgn恢复到默认 </a> </li> <li class=md-nav__item> <a href=#getrgnbox class=md-nav__link> GetRgnBox </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#dc class=md-nav__link> 内存DC不能绘制 </a> </li> <li class=md-nav__item> <a href=#bitmap class=md-nav__link> Bitmap透明 </a> <nav class=md-nav aria-label=Bitmap透明> <ul class=md-nav__list> <li class=md-nav__item> <a href=#makergn class=md-nav__link> MakeRgn </a> </li> <li class=md-nav__item> <a href=#cdctransparentblt class=md-nav__link> CDC::TransparentBlt </a> </li> <li class=md-nav__item> <a href=#bittrans class=md-nav__link> 封装BitTrans </a> </li> <li class=md-nav__item> <a href=#stretchtrans class=md-nav__link> 封装StretchTrans </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_17 class=md-nav__link> 双缓冲机制应对频闪 </a> <nav class=md-nav aria-label=双缓冲机制应对频闪> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_18 class=md-nav__link> 不考虑背景色 </a> </li> <li class=md-nav__item> <a href=#_19 class=md-nav__link> 考虑背景色 </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_20 class=md-nav__link> 框架视图 </a> <nav class=md-nav aria-label=框架视图> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_21 class=md-nav__link> 注册窗口类 </a> </li> <li class=md-nav__item> <a href=#mfc_2 class=md-nav__link> MFC环境下创建框架窗口的必备条件 </a> </li> <li class=md-nav__item> <a href=#_22 class=md-nav__link> 关于注册时的要素与窗口设置 </a> </li> <li class=md-nav__item> <a href=#cdialogwm_create class=md-nav__link> 对话框CDialog类不偏爱WM_CREATE消息 </a> </li> <li class=md-nav__item> <a href=#cframewnd class=md-nav__link> CFrameWnd类简介 </a> </li> <li class=md-nav__item> <a href=#precreatewindow class=md-nav__link> PreCreateWindow </a> </li> <li class=md-nav__item> <a href=#clistview class=md-nav__link> 从CListView派生时出错 </a> <nav class=md-nav aria-label=从CListView派生时出错> <ul class=md-nav__list> <li class=md-nav__item> <a href=#toolbar class=md-nav__link> TOOLBar或者菜单的按钮不亮 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_23 class=md-nav__link> 消息传递机制 </a> </li> <li class=md-nav__item> <a href=#chtmlview class=md-nav__link> CHtmlView </a> </li> <li class=md-nav__item> <a href=#csplitterwnd-m_split class=md-nav__link> 视图分割CSplitterWnd m_split; </a> <nav class=md-nav aria-label="视图分割CSplitterWnd m_split;"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#clistctrlclistview class=md-nav__link> CListCtrl与CListView的创建原理： </a> </li> <li class=md-nav__item> <a href=#split class=md-nav__link> Split创建视图、删除视图 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#delete class=md-nav__link> Delete造成的问题 </a> </li> <li class=md-nav__item> <a href=#toolbar_1 class=md-nav__link> ToolBar的使用方法 </a> <nav class=md-nav aria-label=ToolBar的使用方法> <ul class=md-nav__list> <li class=md-nav__item> <a href=#ctoolbar class=md-nav__link> 给CToolBar添加文字 </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_24 class=md-nav__link> 类介绍 </a> <nav class=md-nav aria-label=类介绍> <ul class=md-nav__list> <li class=md-nav__item> <a href=#cgdi class=md-nav__link> CGdi类 </a> <nav class=md-nav aria-label=CGdi类> <ul class=md-nav__list> <li class=md-nav__item> <a href=#cgfiobject class=md-nav__link> CGfiObject </a> </li> <li class=md-nav__item> <a href=#cbitmap class=md-nav__link> CBitmap类 </a> <nav class=md-nav aria-label=CBitmap类> <ul class=md-nav__list> <li class=md-nav__item> <a href=#cbitmapcreatebitmap class=md-nav__link> CBitmap::CreateBitmap </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#crgn_1 class=md-nav__link> CRgn类 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_25 class=md-nav__link> 框架视图 </a> <nav class=md-nav aria-label=框架视图> <ul class=md-nav__list> <li class=md-nav__item> <a href=#cframewnd_1 class=md-nav__link> CFrameWnd类 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_26 class=md-nav__link> 控件类 </a> <nav class=md-nav aria-label=控件类> <ul class=md-nav__list> <li class=md-nav__item> <a href=#ctreectrl class=md-nav__link> CTreeCtrl </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=mfc>MFC随笔记录<a class=headerlink href=#mfc title="Permanent link">*</a></h1> <p>随笔记录一些在上课时应用的MFC知识，以防止应用的时候会忘记。</p> <p>有印象，需要时拿来能用就很好了。</p> <p>工具选项RGB(206,235,206)会比较舒服一些。淡绿色的背景。</p> <h2 id=_1>基础部分<a class=headerlink href=#_1 title="Permanent link">*</a></h2> <h3 id=_2>句柄与对象转换<a class=headerlink href=#_2 title="Permanent link">*</a></h3> <h4 id=hwndcwnd>HWND与CWnd对象之间的转换：<a class=headerlink href=#hwndcwnd title="Permanent link">*</a></h4> <p>a)如果有CWnd对象如何获取这个对象内部的句柄？</p> <div class=highlight><pre><span></span><code>pWnd -&gt;m_hWnd
pWnd -&gt;GetSafeHwnd();
CWnd wnd;
HWND h = wnd;
</code></pre></div> <p>b)如果有句柄HWND如何转为CWnd?</p> <div class=highlight><pre><span></span><code>static CWnd* CWnd::FromHandle(HWND hWnd);
</code></pre></div> <ul> <li>注意：GetDlgItem内部都是靠FromHandle实现的。</li> <li>注意：FromHandle内部是有Map禁止一个句柄被多个对象包含。 就如同一个端口只能被一个进程占用，一个句柄只能有一个对象包含。</li> <li>注意：FromHandle的返回值只限于本函数使用，不可以保存在成员变量长期使用。 原因是不定期清理Map，参见：CWnd::DeleteTempMap</li> </ul> <h4 id=_3>句柄嫁接与子类化：<a class=headerlink href=#_3 title="Permanent link">*</a></h4> <p>a)Attach和Detach就是单纯的嫁接与分离函数。 对象一旦嫁接入一个句柄，就可以自由地调用CWnd或其派生类的功能。 b)子类化Subclass内部包含Attach，额外再增加一个消息转拨到派生类（SubClass就是子类） c)SubClassWindow函数内部核心功能就是Attach和::SetWindowLong d)SubClassWindow必须与UnsubclassWindow()成对使用，如同Attach与Detach那样。 e)SubClassDlgItem是把2个函数合成一个函数：m_eye.SubclassDlgItem(IDC_SHOW, this); m_eye.SubclassWindow(::GetDlgItem(m_hWnd, IDC_SHOW)); f)而且SubClassDlgItem不需要反子类化，可以不用调用UnsubclassWindow</p> <h4 id=_4>总结嫁接与子类化：<a class=headerlink href=#_4 title="Permanent link">*</a></h4> <p>a)Attach和Detach就是单纯的嫁接 b)子类化Subclass内部包含Attach，增强了消息转移机制。 c)SubClassDlgItem简化了子类化功能，不需要反子类化UnsubclassWindow d)类向导中建立关联变量的方法（内部就是子类化）</p> <div class=highlight><pre><span></span><code>DDX_Control函数内的核心内容是，引用类成员变量m_xxx，
{
pDX-&gt;m_pDlgWnd-&gt;GetDlgItem(nIDC, &amp;hWndCtrl);
rControl.SubclassWindow(hWndCtrl))

}
void CXxxxxx::DoDataExchange(CDataExchange* pDX)
{
    CDialogEx::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_LIST, m_list);
    DDX_Control(pDX, IDC_PRIOR, m_combo);
}
</code></pre></div> <h3 id=_5>客户区拖动<a class=headerlink href=#_5 title="Permanent link">*</a></h3> <p>使得在没有标题栏的时候可以拖动窗口，要利用<code>WM_NCHITTEST</code>。</p> <h3 id=_6>定时器使用<a class=headerlink href=#_6 title="Permanent link">*</a></h3> <p>一般是初始化函数设置定时器。</p> <p>WM_TIMER消息映射函数中判断使用函数。</p> <p>定时器间隔最小一般为10-15，吕大师测试的是16ms。</p> <div class=highlight><pre><span></span><code><span class=k>enum</span><span class=w> </span><span class=p>{</span><span class=n>STM_FLYMOVE</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>888</span><span class=p>}</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=n>BOOL</span><span class=w> </span><span class=nf>CMainDlg::OnInitDialog</span><span class=p>()</span>
<span class=p>{</span>
<span class=w>    </span><span class=n>CDialogEx</span><span class=o>::</span><span class=n>OnInitDialog</span><span class=p>();</span>
<span class=w>    </span><span class=n>SetTimer</span><span class=p>(</span><span class=n>STM_FLYMOVE</span><span class=p>,</span><span class=mi>16</span><span class=p>,</span><span class=w> </span><span class=nb>NULL</span><span class=p>);</span><span class=c1>//似乎最小值就是16</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>TRUE</span><span class=p>;</span><span class=w>  </span><span class=c1>// 除非将焦点设置到控件，否则返回 TRUE</span>
<span class=p>}</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>CMainDlg::OnTimer</span><span class=p>(</span><span class=n>UINT_PTR</span><span class=w> </span><span class=n>nIDEvent</span><span class=p>)</span>
<span class=p>{</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>STM_FLYMOVE</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>nIDEvent</span><span class=p>)</span>
<span class=w>    </span><span class=p>{</span>
<span class=w>        </span><span class=n>m_pos</span><span class=p>.</span><span class=n>Offset</span><span class=p>(</span><span class=mi>5</span><span class=o>*</span><span class=n>m_x</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=o>*</span><span class=n>m_y</span><span class=p>);</span><span class=c1>//这实现的是函数调转偏移操作</span>
<span class=w>        </span><span class=n>Invalidate</span><span class=p>(</span><span class=n>FALSE</span><span class=p>);</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>    </span><span class=n>CDialogEx</span><span class=o>::</span><span class=n>OnTimer</span><span class=p>(</span><span class=n>nIDEvent</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <h3 id=_7>获取屏幕宽高<a class=headerlink href=#_7 title="Permanent link">*</a></h3> <p>全屏幕窗口</p> <div class=highlight><pre><span></span><code>int cx = GetSystemMetrics(SM_CXSCREEN);
int cy = GetSystemMetrics(SM_CYSCREEN);
SetWindowPos(NULL, 0, 0, cx, cy, SWP_NOZORDER);
</code></pre></div> <h3 id=_8>坐标转换<a class=headerlink href=#_8 title="Permanent link">*</a></h3> <h4 id=_9>获取控件相对客户区的坐标<a class=headerlink href=#_9 title="Permanent link">*</a></h4> <div class=highlight><pre><span></span><code>CRect rc;//获取控件相对客户区的坐标
m_ok.GetWindowRect(&amp;rc);
ScreenToClient(&amp;rc);//从屏幕坐标，转移至根据主窗口的坐标？
</code></pre></div> <h3 id=_10>布局控件跟随对话框变化<a class=headerlink href=#_10 title="Permanent link">*</a></h3> <p>需要在对话框中，控件的属性调整，属性&gt;动态布局，有两个选项：</p> <ul> <li>调整大小类型，既是大小根据对话框的大小改变。</li> <li>调整移动类型，既是位置根据对话框大小改变。</li> </ul> <p>也可以自己用代码设置</p> <p>计算m_cxMargin：</p> <div class=highlight><pre><span></span><code>BOOL CAboutDlg::OnInitDialog()
{
    CDialogEx::OnInitDialog();
    CRect rect, rc;
    GetClientRect(&amp;rect);
    m_ok.GetWindowRect(&amp;rc);//这个是控件按钮的rect
    ScreenToClient(&amp;rc);//应该是以对话框左上角为中心开始的一个矩形。
    m_cxMargin = rect.right-rc.right;
    m_cyMargin = rect.bottom-rc.bottom;
}
</code></pre></div> <p>m_ok CButton控件根据size移动：</p> <div class=highlight><pre><span></span><code>void CAboutDlg::OnSize(UINT nType, int cx, int cy)
{//m_ok CButton控件根据size移动。
    CDialogEx::OnSize(nType, cx, cy);
    if (m_ok)
    {//根据m_cxMargin平移
        CRect rc;
        m_ok.GetWindowRect(&amp;rc);
        ScreenToClient(&amp;rc);//从屏幕坐标，转移至根据主窗口的坐标？
        int x = cx - m_cxMargin - rc.right;
        int y = cy - m_cyMargin - rc.bottom;//平移的量
        rc.OffsetRect(x, y);
        m_ok.SetWindowPos(NULL, rc.left, rc.top, rc.Width(), rc.Height(), SWP_NOZORDER | SWP_NOSIZE);
    }
}
</code></pre></div> <h3 id=create>Create创建控件的映射方法<a class=headerlink href=#create title="Permanent link">*</a></h3> <p><strong>对于系统预设的控件，可以依照对话框自动生成的方法创建</strong></p> <div class=highlight><pre><span></span><code>    afx_msg void OnMyButtonClick();//头文件中
</code></pre></div> <div class=highlight><pre><span></span><code>    void CMainFrame::OnMyButtonClick()//cpp文件中
    {

    }
</code></pre></div> <div class=highlight><pre><span></span><code>BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    ON_BN_CLICKED(99, OnMyButtonClick)//99为Create时的ID
END_MESSAGE_MAP()
</code></pre></div> <p><strong>对于自定义控件，可能需要用到自定义消息，并依据自定义消息建立映射</strong></p> <h3 id=cimagelist>CImageList的使用<a class=headerlink href=#cimagelist title="Permanent link">*</a></h3> <div class=highlight><pre><span></span><code>void CLeftView::InitCtrl()//可以创建该函数用于初始化CImageList以及其他的东西
{
    m_iList.Create(16, 16, ILC_COLOR32, 8, 8);//CImageList需要初始化才能使用

    m_tree.SetImageList(&amp;m_iList, TVSIL_NORMAL);
    CString sFile;
    for (int i = 0; i &lt; 6; i++)
    {
        sFile.Format(_T(&quot;./res/%d.ico&quot;), i + 1);
        HICON hIcon =(HICON)LoadImage(AfxGetInstanceHandle(), sFile, IMAGE_ICON, 0, 0, LR_LOADFROMFILE);
        m_iList.Add(hIcon);
    }
    m_tree.SetImageList(&amp;m_iList, TVSIL_NORMAL);//CImageList与m_tree绑定。
}
</code></pre></div> <h3 id=clistctrl>CListCtrl单行满满选中<a class=headerlink href=#clistctrl title="Permanent link">*</a></h3> <p>需要属性配合：</p> <div class=highlight><pre><span></span><code>    m_list.ModifyStyle(0, LVS_REPORT LVS_SINGLESEL);//列表模式与单行选中
    m_list.SetExtendedStyle(LVS_EX_GRIDLINES | LVS_EX_FULLROWSELECT);//设置满行选中
</code></pre></div> <p>这样配合NM_ClICK就可以实现一些复杂的功能。</p> <h2 id=gdi>六大GDI绘图对象<a class=headerlink href=#gdi title="Permanent link">*</a></h2> <h3 id=getbitmapbits><code>GetBitmapBits</code>函数<a class=headerlink href=#getbitmapbits title="Permanent link">*</a></h3> <p>在视频软件开发室会用到改函数。视频流文件都形成bits，可以压缩再传输再set。 </p> <p>该函数可以把加载的句柄<code>g_hBitmap</code>，在内存中形成一串代码。代码的长度和像素的个数有关，在内存中一般是<code>bmWidth * bmHeight * 4</code>，文件存储为了节省内存就是<code>bmWidth * bmHeight * 3</code>。</p> <div class=highlight><pre><span></span><code>BITMAP bm;
GetObject(g_hBitmap, sizeof(bm), &amp;bm);
int nCount = bm.bmWidth * bm.bmHeight * 4;
auto p = new char[nCount];
int n = GetBitmapBits(g_hBitmap, nCount, p);
delete[]p;
</code></pre></div> <h3 id=_11>位图贴图流程<a class=headerlink href=#_11 title="Permanent link">*</a></h3> <h4 id=win32>位图显示：（win32）<a class=headerlink href=#win32 title="Permanent link">*</a></h4> <p>（贴图技术）流程尽量背下来</p> <ol> <li>创建内存DC：</li> </ol> <p>HDC mdc = CreateCompatibleDC(hdc);</p> <p>//如果代入NULL代表：GetDC(NULL)桌面关联的DC</p> <ol> <li>内存DC选择位图：</li> </ol> <p>SelectObject(mdc, g_hBitmap);</p> <ol> <li>对窗口DC输出：</li> </ol> <p>BitBlt(hdc, 0, 0, 604, 603, mdc, 0, 0, SRCCOPY);</p> <ol> <li>删除内存DC</li> </ol> <p>DeleteDC(mdc);</p> <div class=highlight><pre><span></span><code>  PAINTSTRUCT ps;//FILE 以前也是结构体，没必要去看内容。WSAStartup这些函数对应的结构体都没必要看。
  HDC hdc = BeginPaint(hWnd, &amp;ps);
  HDC mdc = CreateCompatibleDC(hdc);//如果代入NULL代表：GetDC(NULL)桌面关联的DC
  SelectObject(mdc, g_hBitmap);
  BitBlt(hdc, 0, 0, 604, 603, mdc, 0, 0, SRCCOPY);
  DeleteDC(mdc);
  EndPaint(hWnd, &amp;ps);
</code></pre></div> <h4 id=mfc_1>MFC下的位图显示流程：<a class=headerlink href=#mfc_1 title="Permanent link">*</a></h4> <div class=highlight><pre><span></span><code>CPaintDC dc(this); // 窗口DC
CDC mdc;
BITMAP bm;
m_bitmap.GetBitmap(&amp;bm);
mdc.CreateCompatibleDC(&amp;dc);
mdc.SelectObject(&amp;m_bitmap);
dc.BitBlt(190, 120, bm.bmWidth/2, bm.bmHeight/2, &amp;mdc, bm.bmWidth / 2,  bm.bmHeight / 2, SRCCOPY);
</code></pre></div> <h4 id=bitblt>BitBlt函数：<a class=headerlink href=#bitblt title="Permanent link">*</a></h4> <div class=highlight><pre><span></span><code>BOOL BitBlt(
  HDC   hdcDest,    // 目标设备上下文句柄
  int   nXDest,     // 目标矩形的左上角 x 坐标
  int   nYDest,     // 目标矩形的左上角 y 坐标
  int   nWidth,     // 矩形的宽度                即图片的宽
  int   nHeight,    // 矩形的高度
  HDC   hdcSrc,     // 源设备上下文句柄
  int   nXSrc,      // 源矩形的左上角 x 坐标         即图片的x
  int   nYSrc,      // 源矩形的左上角 y 坐标
  DWORD dwRop       // 光栅操作码
);
</code></pre></div> <h4 id=stretchblt>StretchBlt()拉伸贴图<a class=headerlink href=#stretchblt title="Permanent link">*</a></h4> <p>在使用mdc.SelectObject(&amp;dc)，可以使用dc调用StretchBlt函数来实现普通贴图、图片左右反转和上下翻转，以及放缩。</p> <div class=highlight><pre><span></span><code>    //StrectchBlt放缩
    dc.StretchBlt(0, m_size.cy, m_size.cx*1.5, m_size.cy*1.5, &amp;mdc, 20, 10, m_size.cx-100, m_size.cy-50, SRCCOPY);
    //StrectchBlt反转
    dc.StretchBlt(0, m_size.cy+ m_size.cy * 1.5, m_size.cx, m_size.cy, &amp;mdc, m_size.cx, 0, -m_size.cx , m_size.cy, SRCCOPY);
    //反转中，是先定位起始点，然后取宽度
    //（猜测是从起始点开始，然后沿着宽度的矢量方向打印，倒头后，沿着高度矢量方向移动一格，继续打印。
    //所以这里参数的意思是，起点是（m_size.cx,0)即右上角。截取的长度矢量为（ -m_size.cx , m_size.cy）。
    //即x方向从内存中右至左选取像素点，在对话框中打印出来的是左右翻转。Y方向不变。

    dc.StretchBlt(m_size.cx * 1.5, 0, m_size.cx, m_size.cy, &amp;mdc, m_size.cx - 100, 0, -m_size.cx+90, m_size.cy-100, SRCCOPY);
    //这里若矩形填充不完全，因为第8个参数是-m_size.cx-100，这里没有加括号,应该是-m_size.cx+100。参数填太多会选取一些背景色作为填充。
</code></pre></div> <p><code>pDC-&gt;CreateCompatibleDC(NULL);</code>参数可以是NULL</p> <h3 id=_12>对话框背景后景色的刷新<a class=headerlink href=#_12 title="Permanent link">*</a></h3> <div class=highlight><pre><span></span><code>case WM_ERASEBKGND://消息
        return TRUE;//默认返回 0，如果是非0那么就不会调用默认的刷新背景
        //MFC中 ， 你可以在OnEraseBkgnd函数中返回一个非零值
</code></pre></div> <h3 id=_13>拖动客户区<a class=headerlink href=#_13 title="Permanent link">*</a></h3> <p>在MFC中拖动客户区的方式只需要这个即可，此方法在Win32中不管用。</p> <div class=highlight><pre><span></span><code>LRESULT CHitTestDlg::OnNcHitTest(CPoint point)
{//在WM_NCHITTEST的映射函数中返回HTCAPTION即可。
    return HTCAPTION;//return 别的就是别的功能
    return CDialogEx::OnNcHitTest(point);
}
</code></pre></div> <h3 id=_14>空填充矩形<a class=headerlink href=#_14 title="Permanent link">*</a></h3> <ul> <li>利用CreateBrushIndirect函数来调用BS_NULL属性实现真正的空填充。</li> <li>​ dc.SelectStockObject(NULL_BURSH);</li> </ul> <div class=highlight><pre><span></span><code><span class=w>    </span><span class=c1>//1.是空填充，但是繁琐。  </span>
<span class=w>    </span><span class=n>CRect</span><span class=w> </span><span class=n>rc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>m_size</span><span class=p>.</span><span class=n>cx</span><span class=p>,</span><span class=n>m_size</span><span class=p>.</span><span class=n>cy</span><span class=w> </span><span class=p>};</span>
<span class=w>    </span><span class=n>CBrush</span><span class=w> </span><span class=n>brush</span><span class=p>;</span>
<span class=w>    </span><span class=n>LOGBRUSH</span><span class=w> </span><span class=n>lb</span><span class=p>{</span><span class=w> </span><span class=n>BS_NULL</span><span class=w> </span><span class=p>};</span>
<span class=w>    </span><span class=n>brush</span><span class=p>.</span><span class=n>CreateBrushIndirect</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lb</span><span class=p>);</span>

<span class=w>    </span><span class=c1>//2.这个空填充方式比上一个好，一句搞定</span>
<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>SelectStockObject</span><span class=p>(</span><span class=n>NULL_BRUSH</span><span class=p>);</span>

<span class=w>    </span><span class=n>CPen</span><span class=w> </span><span class=nf>pen</span><span class=p>(</span><span class=n>PS_SOLID</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=n>RGB</span><span class=p>(</span><span class=mi>255</span><span class=p>,</span><span class=w> </span><span class=mi>255</span><span class=p>,</span><span class=w> </span><span class=mi>125</span><span class=p>));</span>
<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>SelectObject</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pen</span><span class=p>);</span>
<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>SelectObject</span><span class=p>(</span><span class=o>&amp;</span><span class=n>brush</span><span class=p>);</span>
<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>Rectangle</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rc</span><span class=p>);</span>
</code></pre></div> <h3 id=crgn>CRgn使用示例<a class=headerlink href=#crgn title="Permanent link">*</a></h3> <h4 id=_15>绘制一个圆形的图片<a class=headerlink href=#_15 title="Permanent link">*</a></h4> <p>利用Rgn，选取一个圆形区域，利用圆形区域绘制一个图。</p> <div class=highlight><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>CRgnDlg::OnPaint</span><span class=p>()</span>
<span class=p>{</span>
<span class=w>    </span><span class=n>CPaintDC</span><span class=w> </span><span class=n>dc</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=w> </span><span class=c1>// 用于绘制的设备上下文</span>
<span class=w>    </span><span class=n>CRect</span><span class=w> </span><span class=n>rc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>m_size</span><span class=p>.</span><span class=n>cx</span><span class=p>,</span><span class=n>m_size</span><span class=p>.</span><span class=n>cy</span><span class=w> </span><span class=p>};</span>
<span class=w>    </span><span class=n>rc</span><span class=p>.</span><span class=n>OffsetRect</span><span class=p>(</span><span class=mi>50</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span>
<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>FillSolidRect</span><span class=p>(</span><span class=n>CRect</span><span class=p>{</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>800</span><span class=p>,</span><span class=mi>800</span><span class=w> </span><span class=p>},</span><span class=w> </span><span class=n>RGB</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>155</span><span class=p>,</span><span class=w> </span><span class=mi>125</span><span class=p>));</span>

<span class=w>    </span><span class=c1>//创建一个Rgn</span>
<span class=w>    </span><span class=c1>//CRgn用于表示和处理裁剪区域，裁剪区域是指一个图形区域，</span>
<span class=w>    </span><span class=c1>//它定义了一个矩形区域内可以绘制的图形区域，超出这个区域的绘制会被剪裁掉，不会显示在屏幕上。</span>
<span class=w>    </span><span class=n>CRgn</span><span class=w> </span><span class=n>rgn</span><span class=p>;</span>
<span class=w>    </span><span class=n>rgn</span><span class=p>.</span><span class=n>CreateEllipticRgn</span><span class=p>(</span><span class=n>rc</span><span class=p>.</span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>rc</span><span class=p>.</span><span class=n>top</span><span class=p>,</span><span class=w> </span><span class=n>rc</span><span class=p>.</span><span class=n>right</span><span class=p>,</span><span class=w> </span><span class=n>rc</span><span class=p>.</span><span class=n>bottom</span><span class=p>);</span>

<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>SelectObject</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rgn</span><span class=p>);</span>
<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>BitBlt</span><span class=p>(</span><span class=mi>50</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>m_size</span><span class=p>.</span><span class=n>cx</span><span class=p>,</span><span class=w> </span><span class=n>m_size</span><span class=p>.</span><span class=n>cy</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>m_dc</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>SRCCOPY</span><span class=p>);</span>

<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>SelectClipRgn</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span><span class=w> </span><span class=c1>// 恢复原始裁剪区域</span>
<span class=p>}</span>
</code></pre></div> <h4 id=_16>绘制一个自定义的窗口<a class=headerlink href=#_16 title="Permanent link">*</a></h4> <p>利用Rgn，选取绘制范围，利用<code>SetWindowRgn</code>绘制一个自定义的窗口</p> <div class=highlight><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>CRgnDlg::OnPaint</span><span class=p>()</span>
<span class=p>{</span>
<span class=w>    </span><span class=n>CPaintDC</span><span class=w> </span><span class=n>dc</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=w> </span><span class=c1>// 用于绘制的设备上下文</span>
<span class=w>    </span><span class=n>CRect</span><span class=w> </span><span class=n>rc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>m_size</span><span class=p>.</span><span class=n>cx</span><span class=p>,</span><span class=n>m_size</span><span class=p>.</span><span class=n>cy</span><span class=w> </span><span class=p>};</span><span class=c1>//图片尺寸</span>

<span class=w>    </span><span class=n>CRgn</span><span class=w> </span><span class=n>rgn</span><span class=p>;</span><span class=c1>//图片的Rgn</span>
<span class=w>    </span><span class=n>rgn</span><span class=p>.</span><span class=n>CreateEllipticRgn</span><span class=p>(</span><span class=n>rc</span><span class=p>.</span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>rc</span><span class=p>.</span><span class=n>top</span><span class=p>,</span><span class=w> </span><span class=n>rc</span><span class=p>.</span><span class=n>right</span><span class=p>,</span><span class=w> </span><span class=n>rc</span><span class=p>.</span><span class=n>bottom</span><span class=p>);</span>

<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>SelectObject</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rgn</span><span class=p>);</span>
<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>BitBlt</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>m_size</span><span class=p>.</span><span class=n>cx</span><span class=p>,</span><span class=w> </span><span class=n>m_size</span><span class=p>.</span><span class=n>cy</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>m_dc</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>SRCCOPY</span><span class=p>);</span>

<span class=w>    </span><span class=n>CRgn</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=c1>//窗口的Rgn</span>
<span class=w>    </span><span class=n>r</span><span class=p>.</span><span class=n>CreateRectRgn</span><span class=p>(</span><span class=mi>50</span><span class=p>,</span><span class=w> </span><span class=mi>50</span><span class=p>,</span><span class=w> </span><span class=mi>500</span><span class=p>,</span><span class=w> </span><span class=mi>500</span><span class=p>);</span>
<span class=w>    </span><span class=n>SetWindowRgn</span><span class=p>(</span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=n>FALSE</span><span class=p>);</span>
<span class=w>    </span><span class=c1>//在SetWindowRgn后，只是绘制选中区域的Rgn，其他部分不绘制，但是坐标没有变化。</span>
<span class=w>    </span><span class=c1>//比如示例中，重绘后的小矩形窗口，左上角坐标为50,50。</span>
<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>SelectClipRgn</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span><span class=w> </span><span class=c1>// 恢复原始裁剪区域</span>
<span class=p>}</span>
</code></pre></div> <h4 id=rgn>Rgn合并<a class=headerlink href=#rgn title="Permanent link">*</a></h4> <p>利用<code>CombineRgn(&amp;r, &amp;r1, RGN_COPY);</code>可以实现Rgn的挖去与重叠，交集、并集等。</p> <ul> <li>RGN_AND 使用复盖率区域两个区域(型交叉处）。</li> <li> <p>RGN_COPY 创建区域1的副本(由 pRgn1）。</p> </li> <li> <p>RGN_DIFF 创建包含不属于区域2的区域区域1的区域(由 pRgn1) (由 pRgn2）。</p> </li> <li> <p>RGN_OR 全文合并两个区域(联合）。</p> </li> <li> <p>RGN_XOR 合并两个区域，但取消复盖率区域</p> </li> </ul> <div class=highlight><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>CRGN类简介Dlg::OnPaint</span><span class=p>()</span>
<span class=p>{</span>
<span class=w>    </span><span class=n>CPaintDC</span><span class=w> </span><span class=n>dc</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=w> </span><span class=c1>// 用于绘制的设备上下文</span>
<span class=w>    </span><span class=n>CRgn</span><span class=w> </span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=n>r1</span><span class=p>;</span>
<span class=w>    </span><span class=n>POINT</span><span class=w> </span><span class=n>pts</span><span class=p>[]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>{</span><span class=mi>334</span><span class=p>,</span><span class=mi>120</span><span class=p>},{</span><span class=mi>596</span><span class=p>,</span><span class=mi>345</span><span class=p>},{</span><span class=mi>497</span><span class=p>,</span><span class=mi>529</span><span class=p>},{</span><span class=mi>217</span><span class=p>,</span><span class=mi>517</span><span class=p>},</span>
<span class=w>    </span><span class=p>{</span><span class=mi>118</span><span class=p>,</span><span class=mi>406</span><span class=p>},{</span><span class=mi>319</span><span class=p>,</span><span class=mi>319</span><span class=p>}</span><span class=w> </span><span class=p>};</span>
<span class=w>    </span><span class=n>r</span><span class=p>.</span><span class=n>CreateEllipticRgn</span><span class=p>(</span><span class=mi>30</span><span class=p>,</span><span class=w> </span><span class=mi>30</span><span class=p>,</span><span class=w> </span><span class=mi>500</span><span class=p>,</span><span class=w> </span><span class=mi>400</span><span class=p>);</span>
<span class=w>    </span><span class=n>r1</span><span class=p>.</span><span class=n>CreatePolygonRgn</span><span class=p>(</span><span class=n>pts</span><span class=p>,</span><span class=n>_countof</span><span class=p>(</span><span class=n>pts</span><span class=p>),</span><span class=w> </span><span class=n>ALTERNATE</span><span class=p>);</span>
<span class=w>    </span><span class=c1>//这个ALTERANTE加载模式不知道有什么区别。</span>
<span class=w>    </span><span class=n>r</span><span class=p>.</span><span class=n>CombineRgn</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>r1</span><span class=p>,</span><span class=w> </span><span class=n>RGN_COPY</span><span class=p>);</span>
<span class=c1>//  RGN_XOR 共同部分挖掉</span>
<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>SelectObject</span><span class=p>(</span><span class=n>r</span><span class=p>);</span>
<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>BitBlt</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>m_size</span><span class=p>.</span><span class=n>cx</span><span class=p>,</span><span class=w> </span><span class=n>m_size</span><span class=p>.</span><span class=n>cy</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>m_dc</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>SRCCOPY</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <h4 id=rgn_1>Rgn恢复到默认<a class=headerlink href=#rgn_1 title="Permanent link">*</a></h4> <p>因为<code>int SelectObject(CRgn rgn)</code>没有返回旧的对象，所以不能用记录旧RGN的方式返回。</p> <p>可以使用Bitmap来回复旧Rgn。</p> <div class=highlight><pre><span></span><code>    BITMAP bm;
    dc.GetCurrentBitmap()-&gt;GetBitmap(&amp;bm);
    //这个bm的尺寸就是旧Bitmap画布的尺寸。
    r.DeleteObject();
    r.CreateRectRgn(0, 0, bm.bmWidth, bm.bmHeight);
    //把rgn恢复到默认。因为dc没有SelectBitmap，所以默认的CurrentBitmap就是画布原本的大小。
    dc.SelectObject(&amp;r);
</code></pre></div> <h4 id=getrgnbox>GetRgnBox<a class=headerlink href=#getrgnbox title="Permanent link">*</a></h4> <p>GetRgnBox可以获得最小收束的矩形。</p> <p>GetRegionData可以获得</p> <div class=highlight><pre><span></span><code>    CRect rect;
    r.GetRgnBox(rect);

    int nCount = r.GetRegionData(NULL, 0) ;
    //带入NULL返回值包含对区域数据需要字节数，有点像字节转换那里
    auto p = new char[nCount];
    LPRGNDATA pData = (LPRGNDATA)p;
    int n = r.GetRegionData(pData, nCount);
    sizeof(RGNDATA);
    //一般与CreateFromData一起使用，但是我不会。
</code></pre></div> <h3 id=dc>内存DC不能绘制<a class=headerlink href=#dc title="Permanent link">*</a></h3> <p>内存DC不能绘制问题的解决。内存DC绘制的探究。</p> <p>正常情况下，不能绘制要考虑到是不是矩形的面积小于等于0导致不能绘制，或者绘制的位置超过了显示的范围。</p> <p>在这里是内存DC没有SelectObject导致的。因为没有Select，默认的CBitmap大小又只有1，所以不能成功的绘制出图片。</p> <div class=highlight><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>C内存DC探究Dlg::OnPaint</span><span class=p>()</span>
<span class=p>{</span>
<span class=w>    </span><span class=n>CPaintDC</span><span class=w> </span><span class=n>dc</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=w> </span><span class=c1>// 用于绘制的设备上下文</span>

<span class=w>    </span><span class=n>CDC</span><span class=w> </span><span class=n>mdc</span><span class=p>;</span>
<span class=w>    </span><span class=n>mdc</span><span class=p>.</span><span class=n>CreateCompatibleDC</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>

<span class=w>    </span><span class=n>BITMAP</span><span class=w> </span><span class=n>bm</span><span class=p>;</span>
<span class=w>    </span><span class=k>auto</span><span class=w> </span><span class=n>pBitmap</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mdc</span><span class=p>.</span><span class=n>GetCurrentBitmap</span><span class=p>();</span>
<span class=w>    </span><span class=n>pBitmap</span><span class=o>-&gt;</span><span class=n>GetBitmap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bm</span><span class=p>);</span>
<span class=w>    </span><span class=c1>//由上面的语句可以知道，内存DC默认的Bitmap画布只有一个字节，一个像素，所以dc.BitBlt没有作用。</span>
<span class=w>    </span><span class=n>pBitmap</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dc</span><span class=p>.</span><span class=n>GetCurrentBitmap</span><span class=p>();</span>
<span class=w>    </span><span class=n>pBitmap</span><span class=o>-&gt;</span><span class=n>GetBitmap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bm</span><span class=p>);</span>
<span class=w>    </span><span class=c1>//CPaintDC 默认的Bitmap大小与 WindowRect大小一样(宽高一样）。</span>

<span class=w>    </span><span class=n>CBitmap</span><span class=w> </span><span class=n>bmp</span><span class=p>;</span>
<span class=w>    </span><span class=n>bmp</span><span class=p>.</span><span class=n>CreateCompatibleBitmap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>dc</span><span class=p>,</span><span class=w> </span><span class=mi>300</span><span class=p>,</span><span class=w> </span><span class=mi>300</span><span class=p>);</span>
<span class=w>    </span><span class=c1>//新创建的位图将与这个设备dc上下文兼容。这意味着位图的特性将与指定设备上下文匹配，</span>
<span class=w>    </span><span class=c1>//包括位图的位深度、颜色表等。 </span>
<span class=w>    </span><span class=n>mdc</span><span class=p>.</span><span class=n>SelectObject</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bmp</span><span class=p>);</span>
<span class=w>    </span><span class=c1>//在创建了DC并选择后，就可以绘制出图案了，不过默认的CBitmap往往是32位，数值为0x00000000。</span>
<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>FillSolidRect</span><span class=p>(</span><span class=n>CRect</span><span class=p>{</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>200</span><span class=p>,</span><span class=mi>200</span><span class=w> </span><span class=p>},</span><span class=w> </span><span class=n>RGB</span><span class=p>(</span><span class=mi>255</span><span class=p>,</span><span class=w> </span><span class=mi>255</span><span class=p>,</span><span class=w> </span><span class=mi>125</span><span class=p>));</span>
<span class=w>    </span><span class=n>dc</span><span class=p>.</span><span class=n>BitBlt</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=mi>300</span><span class=p>,</span><span class=w> </span><span class=mi>300</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>mdc</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>SRCCOPY</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <h3 id=bitmap>Bitmap透明<a class=headerlink href=#bitmap title="Permanent link">*</a></h3> <p>透明的方法:</p> <ul> <li>MakeRgn和SelectObject(Rgn)</li> <li>自己通过算法封装透明方法：参见CMemoryDC类。</li> <li>CDC::TransparentBlt或者同名API。</li> <li>CImage类（CImage::TransparentBlt）</li> </ul> <h4 id=makergn>MakeRgn<a class=headerlink href=#makergn title="Permanent link">*</a></h4> <p>利用GetPixel(j, i)，判断像素等不等于背景，若不能，则用RGN_OR进行Rgn合并。</p> <p>注意的是rResource.CreateRectRgn(0, 0, 0, 0)；的rgn区域为0，1个像素是（0,0,1,1）。</p> <div class=highlight><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>MakeRgn</span><span class=p>(</span><span class=n>CRgn</span><span class=o>&amp;</span><span class=w> </span><span class=n>rResource</span><span class=p>,</span><span class=w> </span><span class=n>COLORREF</span><span class=w> </span><span class=n>col</span><span class=p>)</span>
<span class=p>{</span><span class=c1>//利用MakeRgn逐个像素检查合并，形成一个没有背景色的Rgn区域。</span>
<span class=w>    </span><span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>rResource</span><span class=p>.</span><span class=n>GetSafeHandle</span><span class=p>())</span>
<span class=w>        </span><span class=n>rResource</span><span class=p>.</span><span class=n>CreateRectRgn</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span>
<span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>m_size</span><span class=p>.</span><span class=n>cy</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span>
<span class=w>    </span><span class=p>{</span>
<span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>m_size</span><span class=p>.</span><span class=n>cx</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>j</span><span class=p>)</span>
<span class=w>        </span><span class=p>{</span>
<span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>GetPixel</span><span class=p>(</span><span class=n>j</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>col</span><span class=p>)</span>
<span class=w>            </span><span class=p>{</span>
<span class=w>                </span><span class=n>CRgn</span><span class=w> </span><span class=n>rTemp</span><span class=p>;</span>
<span class=w>                </span><span class=n>rTemp</span><span class=p>.</span><span class=n>CreateRectRgn</span><span class=p>(</span><span class=n>j</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=c1>//1x1 像素,这里的ij有一点颠倒</span>
<span class=w>                </span><span class=n>rResource</span><span class=p>.</span><span class=n>CombineRgn</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rResource</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>rTemp</span><span class=p>,</span><span class=w> </span><span class=n>RGN_OR</span><span class=p>);</span>
<span class=w>            </span><span class=p>}</span>
<span class=w>        </span><span class=p>}</span>
<span class=w>    </span><span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <h4 id=cdctransparentblt>CDC::TransparentBlt<a class=headerlink href=#cdctransparentblt title="Permanent link">*</a></h4> <p>据说老版本可能不太好用，但最新的VS MFC 中很好用。</p> <div class=highlight><pre><span></span><code>BOOL TransparentBlt(
   int xDest,
   int yDest,
   int nDestWidth,
   int nDestHeight,
   CDC* pSrcDC,
   int xSrc,
   int ySrc,
   int nSrcWidth,
   int nSrcHeight,
   UINT clrTransparent //在将的源位图的RGB颜色透明
);//类似StretchBlt。
</code></pre></div> <h4 id=bittrans>封装BitTrans<a class=headerlink href=#bittrans title="Permanent link">*</a></h4> <p>来自吕大师的代码</p> <p>OnPaint中，pDC带入dc，因为内部用dc调用BitBlt。</p> <p>BitTrans：</p> <div class=highlight><pre><span></span><code>void BitTrans(
        int nXDest,     // 目标起点X
        int nYDest,     // 目标起点Y
        int nWidthDest, // 目标宽度
        int nHeightDest,// 目标高度
        CDC* pDC,       // 目标DC
        int nXSrc,      // 来源起点X
        int nYSrc,      // 来源起点Y
        COLORREF crTrans// 透明色
    )
    {
        CMemoryDC dcImage(nWidthDest, nHeightDest, pDC);//临时DC
        CBitmap bmpMask;
        bmpMask.CreateBitmap(nWidthDest, nHeightDest, 1, 1, NULL);            // 创建单色掩码位图
        CDC dcMask;//掩码DC 
        dcMask.CreateCompatibleDC(pDC);
        dcMask.SelectObject(bmpMask);
        //将载入位图的内存DC中的位图，拷贝到临时DC中
        dcImage.BitBlt(0, 0, nWidthDest, nHeightDest, this, nXSrc, nYSrc, SRCCOPY);

        // 设置临时DC的透明色
        dcImage.SetBkColor(crTrans);
        //掩码DC的透明区域为白色其它区域为黑色
        dcMask.BitBlt(0, 0, nWidthDest, nHeightDest, &amp;dcImage, 0, 0, SRCCOPY);

        //临时DC透明区域为黑色，其它区域保持不变
        dcImage.SetBkColor(RGB(0, 0, 0));
        dcImage.SetTextColor(RGB(255, 255, 255));
        dcImage.BitBlt(0, 0, nWidthDest, nHeightDest, &amp;dcMask, 0, 0, SRCAND);

        // 目标DC透明部分保持屏幕不变，其它部分变成黑色
        pDC-&gt;SetBkColor(RGB(255, 255, 255));
        pDC-&gt;SetTextColor(RGB(0, 0, 0));
        pDC-&gt;BitBlt(nXDest, nYDest, nWidthDest, nHeightDest, &amp;dcMask, 0, 0, SRCAND);
        pDC-&gt;BitBlt(nXDest, nYDest, nWidthDest, nHeightDest, &amp;dcImage, 0, 0, SRCPAINT);
    }
</code></pre></div> <h4 id=stretchtrans>封装StretchTrans<a class=headerlink href=#stretchtrans title="Permanent link">*</a></h4> <div class=highlight><pre><span></span><code>void StretchTrans(
        int nXDest,         // 目标起点X
        int nYDest,         // 目标起点Y
        int nWidthDest,     // 目标宽度
        int nHeightDest,    // 目标高度
        CDC* pDC,           // 目标DC
        int nXSrc,          // 来源起点X
        int nYSrc,          // 来源起点Y
        int nWidthSrc,      // 来源宽度
        int nHeightSrc,     // 来源高度
        COLORREF crTrans    // 透明色
    )
    {
        CMemoryDC dcImage(nWidthDest, nHeightDest, pDC);//临时DC
        CBitmap bmpMask;
        // 创建单色掩码位图
        bmpMask.CreateBitmap(nWidthDest, nHeightDest, 1, 1, NULL);
        CDC dcMask;
        dcMask.CreateCompatibleDC(pDC);
        dcMask.SelectObject(bmpMask);

        // 将载入位图的内存DC中的位图，拷贝到临时DC中
        if (nWidthDest == nWidthSrc &amp;&amp; nHeightDest == nHeightSrc)
            dcImage.BitBlt(0, 0, nWidthDest, nHeightDest, this, nXSrc, nYSrc, SRCCOPY);
        else
            dcImage.StretchBlt(0, 0, nWidthDest, nHeightDest,
                this, nXSrc, nYSrc, nWidthSrc, nHeightSrc, SRCCOPY);

        // 设置临时DC的透明色
        dcImage.SetBkColor(crTrans);
        //掩码DC的透明区域为白色其它区域为黑色
        dcMask.BitBlt(0, 0, nWidthDest, nHeightDest, &amp;dcImage, 0, 0, SRCCOPY);

        //临时DC透明区域为黑色，其它区域保持不变
        dcImage.SetBkColor(RGB(0, 0, 0));
        dcImage.SetTextColor(RGB(255, 255, 255));
        dcImage.BitBlt(0, 0, nWidthDest, nHeightDest, &amp;dcMask, 0, 0, SRCAND);

        // 目标DC透明部分保持屏幕不变，其它部分变成黑色
        pDC-&gt;SetBkColor(RGB(255, 255, 255));
        pDC-&gt;SetTextColor(RGB(0, 0, 0));
        pDC-&gt;BitBlt(nXDest, nYDest, nWidthDest, nHeightDest, &amp;dcMask, 0, 0, SRCAND);
        pDC-&gt;BitBlt(nXDest, nYDest, nWidthDest, nHeightDest, &amp;dcImage, 0, 0, SRCPAINT);
    }
</code></pre></div> <h3 id=_17>双缓冲机制应对频闪<a class=headerlink href=#_17 title="Permanent link">*</a></h3> <p>OnPaint绘图会发生闪烁，而且贴图越多，闪烁越频繁，单张贴图不闪。这是贴图交替输出造成的。</p> <p>这里需要用到双缓冲机制，核心是：把贴图先贴到内存上，再由dc输出内存dc就好了。只贴一次。</p> <p>m_dc的尺寸是变动的。</p> <p>理论上都要做双缓冲，面积太小没啥影响可以不做双缓冲。</p> <h4 id=_18>不考虑背景色<a class=headerlink href=#_18 title="Permanent link">*</a></h4> <p>即<code>Invalidate(FALSE);</code>不刷新背景。</p> <p>m_dc要随着尺寸变化，并且也需要初始化：</p> <div class=highlight><pre><span></span><code>void Clvxin31Dlg::OnSize(UINT nType, int cx, int cy)
{
    CDialogEx::OnSize(nType, cx, cy);
    m_dc.DeleteDC();
    m_dc.Create(cx, cy);
}
</code></pre></div> <p>m_dc在类中定义，核心算法</p> <div class=highlight><pre><span></span><code>void CMainDlg::OnPaint()
{
    CPaintDC dc(this); // 用于绘制的设备上下文
    CRect rect;
    GetWindowRect(&amp;rect);
    m_dc.SetStretchBltMode(STRETCH_HALFTONE);
    m_dc.StretchBlt(0, 0, rect.Width(), rect.Height(), &amp;m_dcBack,
        0, 0, m_dcBack.GetWidth(), m_dcBack.GetHeight(), SRCCOPY);
    CMemoryDC mdc;
    mdc.Create(300, 300);
    m_dc.BitBlt(300, 300, 300, 300, &amp;mdc, 0, 0, SRCCOPY);

    CRect rectClient;
    GetClientRect(&amp;rectClient);
//根据链表动态打印蝴蝶。
    auto pos = m_list.GetHeadPosition();
    while (pos)
    {
        Flys&amp; data = m_list.GetNext(pos);
        //这里需要加引用。
        data.m_pos.Offset(data.m_dir);
        //蝴蝶碰到边缘反弹回来
        if (data.m_pos.x&lt;rectClient.left || data.m_pos.x + m_dcFlys-&gt;GetWidth()&gt;rectClient.right)
            data.m_dir.x *= -1;
        if (data.m_pos.y&lt;rectClient.top || data.m_pos.y + m_dcFlys-&gt;GetHeight()&gt;rectClient.bottom)
            data.m_dir.y *= -1;
        //蝴蝶的贴图。
        m_dc.TransparentBlt(data.m_pos.x, data.m_pos.y, m_dcFlys-&gt;GetWidth(), m_dcFlys-&gt;GetHeight(),
            &amp;m_dcFlys[data.m_nFlyIndex], 0, 0, m_dcFlys-&gt;GetWidth(), m_dcFlys-&gt;GetHeight(), RGB(255, 0, 255));
        if (++data.m_nFlyIndex &gt;= _countof(m_dcFlys))
            data.m_nFlyIndex = 0;
    }
    所有都输入到m_dc后，只用dc打印一次m_dc即可。
    dc.BitBlt(0, 0, m_dc.GetWidth(), m_dc.GetHeight(), &amp;m_dc, 0, 0, SRCCOPY);
}
</code></pre></div> <h4 id=_19>考虑背景色<a class=headerlink href=#_19 title="Permanent link">*</a></h4> <p>两种解决方案：</p> <ol> <li>使用<code>Invalidate(FALSE);</code>，带入FALSE而不是TRUE，可以免刷新背景造成的重复刷新闪烁。</li> <li>在WM_ERASEBKGND的映射函数中return TRUE，使背景色刷新失效。如果要使用背景，可以在OnPaint中伪造背景。</li> </ol> <h2 id=_20>框架视图<a class=headerlink href=#_20 title="Permanent link">*</a></h2> <h3 id=_21>注册窗口类<a class=headerlink href=#_21 title="Permanent link">*</a></h3> <p>classname注册窗口类型名：有3种方式注册</p> <ul> <li>原始API：<code>ATOM RegisterClass(const WNDCLASS *lpWndClass);</code></li> <li>MFC封装之后叫做<code>AfxRegisterClass</code>，类似于<code>AfxMessageBox</code>封装了<code>MessageBox(API)</code></li> <li>MFC再次封装了一个真正的简易注册函数叫做：<code>AfxRegisterWndClass</code> 返回值是自动生成字符串，字符串的内容包括三要素的句柄sprintf生成的文字：</li> </ul> <p><code>AfxRegisterWndClass</code>因为框架只需要框架，视图会覆盖框架，并实现视图的功能，所以一般都默认用简易注册。</p> <p>类名为HCursor等句柄sprintf后形成的一长串数字。以之前的CLadderCtrl为例，需要在Create函数中操作。</p> <p>自定义窗口类都可以搞一搞。</p> <div class=highlight><pre><span></span><code>BOOL CLadderCtrl::Create(DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID)
{
    if (!IsRegistered(_T(&quot;王八蛋&quot;)))//应该是可以防止重复创建窗口类？
    {//WNDCLASS结构体创建与赋值
        WNDCLASS wc = { CS_HREDRAW | CS_VREDRAW };//左右上下拉伸刷新
        wc.hCursor = theApp.LoadStandardCursor(IDC_HAND);
        wc.hbrBackground = m_brBk;
        wc.lpfnWndProc = ::DefWindowProc;
        wc.lpszClassName = _T(&quot;王八蛋&quot;);
        RegisterClass(&amp;wc);//为什么Create(_T(&quot;Edit&quot;)
    }
    return this-&gt;CWnd::Create(_T(&quot;王八蛋&quot;), NULL, dwStyle, rect, pParentWnd, nID);
    //记得Create函数中添加新注册的类名。
}
</code></pre></div> <div class=highlight><pre><span></span><code>inline static bool IsRegistered(LPCTSTR sClass)
{//可用这个函数判断
    WNDCLASSEX wcex;
    return (GetClassInfoEx(NULL, sClass, &amp;wcex) != 0);
}
</code></pre></div> <div class=highlight><pre><span></span><code><span class=n>LPCTSTR</span><span class=w>  </span><span class=nf>AfxRegisterWndClass</span><span class=p>(</span><span class=w> </span>
<span class=w>   </span><span class=n>UINT</span><span class=w> </span><span class=n>nClassStyle</span><span class=p>,</span><span class=w> </span>
<span class=w>   </span><span class=n>HCURSOR</span><span class=w> </span><span class=n>hCursor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span>
<span class=w>   </span><span class=n>HBRUSH</span><span class=w> </span><span class=n>hbrBackground</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span>
<span class=w>   </span><span class=n>HICON</span><span class=w> </span><span class=n>hIcon</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=w>  </span>
<span class=p>);</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=n>附录</span><span class=err>：</span><span class=n>AfxRegisterClass比API就是多了GetClassInfo探测一下是否已注册过了</span><span class=err>。</span>
<span class=n>BOOL</span><span class=w> </span><span class=n>AFXAPI</span><span class=w> </span><span class=n>AfxRegisterClass</span><span class=p>(</span><span class=n>WNDCLASS</span><span class=o>*</span><span class=w> </span><span class=n>lpWndClass</span><span class=p>)</span>
<span class=p>{</span>
<span class=w>    </span><span class=n>WNDCLASS</span><span class=w> </span><span class=n>wndcls</span><span class=p>;</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>GetClassInfo</span><span class=p>(</span><span class=n>lpWndClass</span><span class=o>-&gt;</span><span class=n>hInstance</span><span class=p>,</span><span class=w> </span><span class=n>lpWndClass</span><span class=o>-&gt;</span><span class=n>lpszClassName</span><span class=p>,</span>
<span class=w>        </span><span class=o>&amp;</span><span class=n>wndcls</span><span class=p>))</span>
<span class=w>    </span><span class=p>{</span><span class=c1>// class already registered</span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>TRUE</span><span class=p>;</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>RegisterClass</span><span class=p>(</span><span class=n>lpWndClass</span><span class=p>))</span>
<span class=w>    </span><span class=p>{</span>
<span class=w>        </span><span class=n>TRACE</span><span class=p>(</span><span class=n>traceAppMsg</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>_T</span><span class=p>(</span><span class=s>&quot;Can&#39;t register window class named %Ts</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>),</span>
<span class=w>            </span><span class=n>lpWndClass</span><span class=o>-&gt;</span><span class=n>lpszClassName</span><span class=p>);</span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>FALSE</span><span class=p>;</span>
<span class=w>    </span><span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <h3 id=mfc_2>MFC环境下创建框架窗口的必备条件<a class=headerlink href=#mfc_2 title="Permanent link">*</a></h3> <ul> <li>InitInstance必须return TRUE;</li> <li>theApp.m_pMainWnd 必须指向主窗口对象地址：</li> <li>主窗口对象必须是堆空间或者生命期足够。</li> </ul> <p>因为Frame是非阻塞，必须返回TRUE。</p> <h3 id=_22>关于注册时的要素与窗口设置<a class=headerlink href=#_22 title="Permanent link">*</a></h3> <ul> <li>例如：注册时你指定灰色背景，窗口生成后可以在WM_ERASEBKGND消息中改成别的颜色。</li> <li>其他包括图标（SetIcon），光标WM_SETCURSOR消息中改，以及菜单（SetMenu）。</li> <li>例如：但凡Create一个Edit注册时的要素都会默认呈现，比如光标的形状，背景是白色。</li> <li>但是后面都是可以改的，比如你想把某个edit改为绿底红字的。（WM_CTLCOLOR）</li> </ul> <p><strong>修改的位置</strong></p> <ul> <li> <p>在InitInstance()中进行修改，Create后，利用SetMenu或者SetIcon等进行修改。</p> </li> <li> <p>注册时，在PreCreateWindow中修改cs结构体的信息。</p> </li> <li>在创建后，利用消息WM_SETCURSOR或者其他位置进行修改。</li> </ul> <h3 id=cdialogwm_create>对话框CDialog类不偏爱WM_CREATE消息<a class=headerlink href=#cdialogwm_create title="Permanent link">*</a></h3> <p>a)对话框类使用WM_INITDIALOG消息或者虚函数来初始化；</p> <p>WM_CREATE消息对于对话框也是有效的对话框程序需要初始化控件，WM_CREATE是主窗口刚刚创建好，控件还没有。所以它偏爱OnInitDialog虚函数，控件都被创建好之后方便初始化那些控件。</p> <h3 id=cframewnd>CFrameWnd类简介<a class=headerlink href=#cframewnd title="Permanent link">*</a></h3> <ul> <li>CFrameWnd类所有的内部窗口都是代码创建的。而不像对话框是拖入的。所以常在WM_CREATE中初始化</li> <li>CFrameWnd::rectDefault管理层叠static const CRect rectDefault;</li> <li>LoadFrame内部包含CreateFrame，同时执行注册以及加载快捷键等</li> </ul> <h3 id=precreatewindow>PreCreateWindow<a class=headerlink href=#precreatewindow title="Permanent link">*</a></h3> <p>创建窗口的预处理函数：<code>virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);</code></p> <p>在这里Create函数前，会进行窗口注册，所以LoadFrame与Create函数都可以不经函数前注册创建窗口。</p> <p>注册的结构体规格包括光标，图标以及背景颜色等；以及位置、高宽以及菜单，style和dwExStyle。</p> <p>cs结构体修改后，例如修改了cs.hMenu（）后，经过注册也可以启用(可能是AfxRegisterWndClass(0)中调用了cs结构体。</p> <p>为什么LoadFrame中使用注册，而CreateFrame根本没注册都好使？ 那就是因为窗口预处理中执行注册，可以说即使从CWnd类派生你只要做预处理就不用RegisterClass。</p> <h3 id=clistview>从CListView派生时出错<a class=headerlink href=#clistview title="Permanent link">*</a></h3> <p>类似从视图控件派生提示未定义的类，需要考虑是否包含了头文件<code>afxcview.h</code>。</p> <h4 id=toolbar>TOOLBar或者菜单的按钮不亮<a class=headerlink href=#toolbar title="Permanent link">*</a></h4> <p>可能是需要添加到类中</p> <ul> <li>在类视图中搜索菜单按钮或者bar按钮的ID，如<code>ID_EDIT_INPUT</code>然后添加到类中建立映射。</li> <li>Menu按钮ID可以与ToolBar控件ID一样，这样可以用一个映射同时起作用。</li> <li>如果ToolBar不亮，点一下List窗口就会亮了</li> </ul> <h3 id=_23>消息传递机制<a class=headerlink href=#_23 title="Permanent link">*</a></h3> <p>在CMainFrame中，OnCmdMsg函数内，可以进行消息派发。</p> <p>例如我同样用ID_EDIT_INPUT，但是该id可以形成多处消息映射，可以在CMainView中映射为函数，也可以在CMainFrame中当做函数。所以这时候需要消息机制来进行派发。默认是主框架处理，没有就在其他地方处理。</p> <p>如果内部添加派发语句，则有限处理其他处的派发。</p> <p>如果return FALSE，那么菜单按钮和ToolBar按钮会变成灰色，很严重。</p> <div class=highlight><pre><span></span><code>BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{//m_pMainView是一个CView类型的指针，可以指向子类封装的函数，不知可不可以。
    if(m_pMainView&amp;&amp;m_pMainView-&gt;OnCmdMsg(nID,nCode,pExtra,pHandlerInfo))
        return TRUE;//表示成功处理，return FALSE 干脆就不刷新了。
    // 否则，执行默认处理
    return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}
</code></pre></div> <h3 id=chtmlview>CHtmlView<a class=headerlink href=#chtmlview title="Permanent link">*</a></h3> <p>这个ie内核，感觉没啥大用，现在谁用着玩意开发网页啊。随便看看就行。</p> <h3 id=csplitterwnd-m_split>视图分割CSplitterWnd m_split;<a class=headerlink href=#csplitterwnd-m_split title="Permanent link">*</a></h3> <p>在使用多个视图时，可以用 <code>CSplitterWnd m_split</code>分割。</p> <div class=highlight><pre><span></span><code>    CSplitterWnd m_split;//头文件中
</code></pre></div> <div class=highlight><pre><span></span><code>    m_split.CreateStatic(this, 1, 2);//分出来的句柄必须填满，有空的就会触发断言
    m_split.CreateView(0, 0, RUNTIME_CLASS(CLeftView), {150,0}, NULL);
    //宽度是150，没有阻挡则延长到边缘，比如此处没有指定上下，所以就是上下通顶。
    m_split.CreateView(0, 1, RUNTIME_CLASS(CRightView), { 150,0 }, NULL);
    theApp.m_pLeftView = (CLeftView*)m_split.GetPane(0, 0);
    theApp.m_pRightView = (CRightView*)m_split.GetPane(0, 0);
    //m_pRightView 也可在各自的构造函数中赋值。
    //放在CApp中，可以实现灵活调用
</code></pre></div> <h4 id=clistctrlclistview>CListCtrl与CListView的创建原理：<a class=headerlink href=#clistctrlclistview title="Permanent link">*</a></h4> <p>a)CListCtrl的内部创建原理是通过CWnd::Create(sClassName,....)来实现的。 b)CStatic,CEdit,CButton的内部创建原理无一不是这个原理，即使是拖入对话框的控件底层也是这样实现的。 （通过.rc读取风格和位置等要素，再调用CWnd类的Create函数） c)CListView和CTreeView整个类都几乎没有代码，其实就是一个变种的CListCtrl或者CTreeCtrl。 d)所以你会看到直接强转：</p> <div class=highlight><pre><span></span><code>INLINE CListCtrl&amp; CListView::GetListCtrl() const
    { return *(CListCtrl*)this; }
</code></pre></div> <h4 id=split>Split创建视图、删除视图<a class=headerlink href=#split title="Permanent link">*</a></h4> <p>分割是做大软件必不可少的一项技术。</p> <div class=highlight><pre><span></span><code>theApp.m_split.CreateView(0, 1, RUNTIME_CLASS(CHomeView), { 150,0 }, NULL); //创建
split.DeleteView(0, 1);//释放
split.RecalcLayout();//刷新
</code></pre></div> <p><strong>如果分隔栏太丑</strong></p> <p>可以用派生类派生CSplitterWnd，然后再OnPaint中重写OnPaint函数进行绘制。</p> <h3 id=delete>Delete造成的问题<a class=headerlink href=#delete title="Permanent link">*</a></h3> <div class=highlight><pre><span></span><code>theApp.m_split.DeleteView(0, 1);
theApp.m_split.CreateView(0, 1, RUNTIME_CLASS(CRightView), { 0,0 }, NULL);
theApp.m_pRightView = (CRightView*)theApp.m_split.GetPane(0, 1);
//这个语法并不安全，以为在delete与theApp.m_pRightView被赋值的期间，该指针处于野指针状态，如果为空，则会出现错误。
</code></pre></div> <p>所以在下方的处理中造成了问题，<code>改用IsWindow(theApp.m_pRightView-&gt;GetSafeHwnd())</code>判断可以解决野指针造成的问题。</p> <div class=highlight><pre><span></span><code>BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
    if (IsWindow(theApp.m_pRightView-&gt;GetSafeHwnd()) &amp;&amp; theApp.m_pRightView-&gt;OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // 否则，执行默认处理
    return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}
</code></pre></div> <h3 id=toolbar_1>ToolBar的使用方法<a class=headerlink href=#toolbar_1 title="Permanent link">*</a></h3> <p>1、高级工具栏的开发 a)文字工具栏开发：调用CToolBar::SetButtonText和CBoolBar::SetSizes方法； b)工具箱创建时要指定：CBRS_SIZE_FIXED 调用CToolBar::SetButtonStyle方法，为n个按钮一行做分行属性。</p> <h4 id=ctoolbar>给CToolBar添加文字<a class=headerlink href=#ctoolbar title="Permanent link">*</a></h4> <p>还有CToolBar停靠在窗口的右侧</p> <div class=highlight><pre><span></span><code>void CMainFrame::InitTools()
{
    LPCTSTR st[] = {
        _T(&quot;新建&quot;),_T(&quot;打开&quot;),_T(&quot;保存&quot;),_T(&quot;&quot;),_T(&quot;剪切&quot;),_T(&quot;拷贝&quot;),_T(&quot;粘贴&quot;),_T(&quot;&quot;),_T(&quot;打印&quot;),_T(&quot;帮助&quot;)
    };
    int nCount = m_wndToolBar.GetCount();
    for (int i = 0; i &lt; nCount; ++i)
    {
        m_wndToolBar.SetButtonText(i, st[i]);
    }
    CRect rect;
    m_wndToolBar.GetItemRect(0, rect);//加文字以后rect变大，如果不SetSizes，文字不会显示
    m_wndToolBar.SetSizes(rect.Size(), { 16,15 });
    GetWindowRect(&amp;rect);

    //toolBox 的悬浮与分割，停靠在窗口的右侧，需要CBRS_SIZE_FIXED属性支持
    m_toolBox.SetButtonStyle(1, TBBS_BUTTON | TBBS_WRAPPED);
    m_toolBox.SetButtonStyle(3, TBBS_BUTTON | TBBS_WRAPPED);
    m_toolBox.SetButtonStyle(5, TBBS_BUTTON | TBBS_WRAPPED);
    m_toolBox.SetButtonStyle(7, TBBS_BUTTON | TBBS_WRAPPED);//需要配合FIXED属性
    FloatControlBar(&amp;m_toolBox, { rect.right - 80,rect.top + 100 });
}
</code></pre></div> <h2 id=_24>类介绍<a class=headerlink href=#_24 title="Permanent link">*</a></h2> <h3 id=cgdi>CGdi类<a class=headerlink href=#cgdi title="Permanent link">*</a></h3> <h4 id=cgfiobject>CGfiObject<a class=headerlink href=#cgfiobject title="Permanent link">*</a></h4> <p>GDI绘图类共同的基类</p> <div class=highlight><pre><span></span><code>typedef void * HGDIOBJ;
class CGdiObject : public CObject
{
public:
// Attributes
    HGDIOBJ m_hObject;     // 用来存储：HPEN HBRUSH HFONT HBITMAP ...
    operator HGDIOBJ() const;
    HGDIOBJ GetSafeHandle() const;
    static CGdiObject* PASCAL FromHandle(HGDIOBJ hObject);
    static void PASCAL DeleteTempMap();  //有点像那个CWnd，也有这个缓存图。这个是清除
    BOOL Attach(HGDIOBJ hObject);   //这个是利用句柄生成
    HGDIOBJ Detach();
// Constructors
    CGdiObject(); // must Create a derived class object
    BOOL DeleteObject();//内部就是API DeleteObject

    UINT GetObjectType() const;
**  BOOL CreateStockObject(int nIndex);//内部是：m_hObject=GetStockObject;
    //这个有点意思，可以输入NULL_BRUSH查看内部默认的那些东西
};
</code></pre></div> <h4 id=cbitmap>CBitmap类<a class=headerlink href=#cbitmap title="Permanent link">*</a></h4> <div class=highlight><pre><span></span><code>class CBitmap : public CGdiObject
{
    DECLARE_DYNAMIC(CBitmap)
public:
    static CBitmap* PASCAL FromHandle(HBITMAP hBitmap);//生成外壳类
// Constructors
    CBitmap();
    BOOL LoadBitmap(LPCTSTR lpszResourceName);
    BOOL LoadBitmap(UINT nIDResource);//加载位图
**  BOOL LoadOEMBitmap(UINT nIDBitmap); // for OBM_/OCR_/OIC_
//这个函数可以加载一些系统的图，包括打钩恢复任务啥的都有。
    BOOL LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0,
        LPCOLORMAP lpColorMap = NULL, int nMapSize = 0);
    BOOL CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount,
            const void* lpBits);
    BOOL CreateBitmapIndirect(LPBITMAP lpBitmap);//根据详细信息创建位图
    BOOL CreateCompatibleBitmap(CDC* pDC, int nWidth, int nHeight);//创建兼容位图
    BOOL CreateDiscardableBitmap(CDC* pDC, int nWidth, int nHeight);
// Attributes
    operator HBITMAP() const;
    int GetBitmap(BITMAP* pBitMap);
// Operations
    DWORD SetBitmapBits(DWORD dwCount, const void* lpBits);
    DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const;
    CSize SetBitmapDimension(int nWidth, int nHeight);
    CSize GetBitmapDimension() const;
// Implementation
public:
    virtual ~CBitmap();
#ifdef _DEBUG
    virtual void Dump(CDumpContext&amp; dc) const;
#endif
};
</code></pre></div> <h5 id=cbitmapcreatebitmap>CBitmap::CreateBitmap<a class=headerlink href=#cbitmapcreatebitmap title="Permanent link">*</a></h5> <p>利用CreateBitmap函数创建CBitmap：</p> <div class=highlight><pre><span></span><code>void CTestDlg::OnPaint()
{
    CPaintDC dc(this); // 用于绘制的设备上下文
    BITMAP bm;
    m_bitmap.GetBitmap(&amp;bm);
    int n = bm.bmHeight*bm.bmWidthBytes;//获取图片的字节数
    void* pBits = new char[n];
    m_bitmap.GetBitmapBits(n,pBits);
    CBitmap bmp;
    bmp.CreateBitmap(bm.bmWidth, bm.bmHeight-300, 1, 32, pBits);
    //以上为生成图片的步骤，注意的是，图片的打印应该是从左至右，从上至下打印的，原图宽为595，高548,
    //所以如果bm.bmWidth如果不是正好等于原图宽，就会打印出很奇怪的图片，差的越多，偏的越大。
    //bm.Height的值相对影响就不是很大。

    //如果用CreateBitmapIndirect构造，则会开辟一块与原图片相同大小的空间，里面的颜色都是黑色。
    bmp.CreateBitmapIndirect(&amp;bm);
    bmp.SetBitmapBits(n, pBits);//把黑色空间填充色彩，n为字节数。
    //如果减去bm.bmWidthBytes，则少打印一行
    CDC mdc;
    mdc.CreateCompatibleDC(&amp;dc);
    mdc.SelectObject(&amp;bmp);
    //贴图
    dc.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &amp;mdc, 0, 0, SRCCOPY);
}
</code></pre></div> <h4 id=crgn_1>CRgn类<a class=headerlink href=#crgn_1 title="Permanent link">*</a></h4> <div class=highlight><pre><span></span><code><span class=k>class</span><span class=w> </span><span class=nc>CRgn</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=k>public</span><span class=w> </span><span class=n>CGdiObject</span>
<span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
<span class=w>    </span><span class=k>static</span><span class=w> </span><span class=n>CRgn</span><span class=o>*</span><span class=w> </span><span class=n>PASCAL</span><span class=w> </span><span class=n>FromHandle</span><span class=p>(</span><span class=n>HRGN</span><span class=w> </span><span class=n>hRgn</span><span class=p>);</span>
<span class=w>    </span><span class=k>operator</span><span class=w> </span><span class=n>HRGN</span><span class=p>()</span><span class=w> </span><span class=k>const</span><span class=p>;</span>

<span class=c1>// 封装的特点是没有使用Overload重载函数，结构体就是XXXIndirect</span>
<span class=w>    </span><span class=n>CRgn</span><span class=p>();</span>
<span class=c1>//创建矩形区域</span>
<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>CreateRectRgn</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x1</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y1</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>x2</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y2</span><span class=p>);</span>
<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>CreateRectRgnIndirect</span><span class=p>(</span><span class=n>LPCRECT</span><span class=w> </span><span class=n>lpRect</span><span class=p>);</span>
<span class=c1>//创建圆形区域</span>
<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>CreateEllipticRgn</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x1</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y1</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>x2</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y2</span><span class=p>);</span>
<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>CreateEllipticRgnIndirect</span><span class=p>(</span><span class=n>LPCRECT</span><span class=w> </span><span class=n>lpRect</span><span class=p>);</span>
<span class=c1>//多边形</span>
<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>CreatePolygonRgn</span><span class=p>(</span><span class=n>LPPOINT</span><span class=w> </span><span class=n>lpPoints</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>nCount</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>nMode</span><span class=p>);</span>
<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>CreatePolyPolygonRgn</span><span class=p>(</span><span class=n>LPPOINT</span><span class=w> </span><span class=n>lpPoints</span><span class=p>,</span><span class=w> </span><span class=n>LPINT</span><span class=w> </span><span class=n>lpPolyCounts</span><span class=p>,</span>
<span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>nCount</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>nPolyFillMode</span><span class=p>);</span>
<span class=c1>//圆角矩形</span>
<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>CreateRoundRectRgn</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x1</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y1</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>x2</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y2</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>x3</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y3</span><span class=p>);</span>
<span class=c1>//</span>
<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>CreateFromPath</span><span class=p>(</span><span class=n>CDC</span><span class=o>*</span><span class=w> </span><span class=n>pDC</span><span class=p>);</span>
<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>CreateFromData</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>XFORM</span><span class=o>*</span><span class=w> </span><span class=n>lpXForm</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>nCount</span><span class=p>,</span>
<span class=w>        </span><span class=k>const</span><span class=w> </span><span class=n>RGNDATA</span><span class=o>*</span><span class=w> </span><span class=n>pRgnData</span><span class=p>);</span>

<span class=c1>// 修改矩形</span>
<span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>SetRectRgn</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x1</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y1</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>x2</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y2</span><span class=p>);</span>
<span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>SetRectRgn</span><span class=p>(</span><span class=n>LPCRECT</span><span class=w> </span><span class=n>lpRect</span><span class=p>);</span>
<span class=c1>//混合</span>
<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>CombineRgn</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>CRgn</span><span class=o>*</span><span class=w> </span><span class=n>pRgn1</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>CRgn</span><span class=o>*</span><span class=w> </span><span class=n>pRgn2</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>nCombineMode</span><span class=p>);</span>
<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>CopyRgn</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>CRgn</span><span class=o>*</span><span class=w> </span><span class=n>pRgnSrc</span><span class=p>);</span>
<span class=c1>//判断区域完全一样</span>
<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>EqualRgn</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>CRgn</span><span class=o>*</span><span class=w> </span><span class=n>pRgn</span><span class=p>)</span><span class=w> </span><span class=k>const</span><span class=p>;</span>
<span class=c1>//判断一个点是否在区域内</span>
<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>PtInRegion</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y</span><span class=p>)</span><span class=w> </span><span class=k>const</span><span class=p>;</span>
<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>PtInRegion</span><span class=p>(</span><span class=n>POINT</span><span class=w> </span><span class=n>point</span><span class=p>)</span><span class=w> </span><span class=k>const</span><span class=p>;</span>
<span class=c1>//保持形状不变偏移</span>
<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>OffsetRgn</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y</span><span class=p>);</span>
<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>OffsetRgn</span><span class=p>(</span><span class=n>POINT</span><span class=w> </span><span class=n>point</span><span class=p>);</span>
<span class=c1>//框图</span>
<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>GetRgnBox</span><span class=p>(</span><span class=n>LPRECT</span><span class=w> </span><span class=n>lpRect</span><span class=p>)</span><span class=w> </span><span class=k>const</span><span class=p>;</span>

<span class=w>    </span><span class=n>BOOL</span><span class=w> </span><span class=nf>RectInRegion</span><span class=p>(</span><span class=n>LPCRECT</span><span class=w> </span><span class=n>lpRect</span><span class=p>)</span><span class=w> </span><span class=k>const</span><span class=p>;</span>
<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>GetRegionData</span><span class=p>(</span><span class=n>LPRGNDATA</span><span class=w> </span><span class=n>lpRgnData</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>nCount</span><span class=p>)</span><span class=w> </span><span class=k>const</span><span class=p>;</span>

<span class=c1>// Implementation</span>
<span class=w>    </span><span class=k>virtual</span><span class=w> </span><span class=o>~</span><span class=n>CRgn</span><span class=p>();</span>
<span class=p>};</span>
</code></pre></div> <h3 id=_25>框架视图<a class=headerlink href=#_25 title="Permanent link">*</a></h3> <h4 id=cframewnd_1>CFrameWnd类<a class=headerlink href=#cframewnd_1 title="Permanent link">*</a></h4> <p>与CDialog一样继承自Dialog但是也有些许的不同</p> <p><strong>CFrameWnd与CDialog类初始化</strong></p> <ul> <li>CDialog类使用WM_INITDIALOG消息或者虚函数来初始化，WM_CREATE消息对于对话框也有效的，为什么对话框很这个消息？对话框程序需要初始化控件，WM_CREATE是主窗口刚刚创建好，控件还没有。所以它偏爱OnInitDialog虚函数，控件都被创建好之后方便初始化那些控件。</li> <li>CFrameWnd类偏爱WM_CREATE，因为所有的内部窗口都是代码创建的。 而不像对话框是拖入的。CFrameWnd::rectDefault管理层叠static const CRect rectDefault;LoadFrame内部包含CreateFrame，同时执行注册以及加载快捷键等（参见附录）</li> </ul> <div class=highlight><pre><span></span><code>class CFrameWnd : public CWnd
{
    DECLARE_DYNCREATE(CFrameWnd)
// Constructors
public:
    static AFX_DATA const CRect rectDefault;
    CFrameWnd();
    BOOL LoadAccelTable(LPCTSTR lpszResourceName);
//创建框架   这个Create内部不会注册 下面的LoadFrame会注册
    virtual BOOL Create(LPCTSTR lpszClassName,
                LPCTSTR lpszWindowName,
                DWORD dwStyle = WS_OVERLAPPEDWINDOW,
                const RECT&amp; rect = rectDefault,
                CWnd* pParentWnd = NULL,        // != NULL for popups
                LPCTSTR lpszMenuName = NULL,
                DWORD dwExStyle = 0,
                CCreateContext* pContext = NULL);

// 加载框架 - load frame and associated resources
    virtual BOOL LoadFrame(UINT nIDResource,
                DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
                CWnd* pParentWnd = NULL,
                CCreateContext* pContext = NULL);

// 创建中央视图 helper for view creation
    CWnd* CreateView(CCreateContext* pContext, UINT nID = AFX_IDW_PANE_FIRST);

// 第十三章文档架构时获取激活文档
    virtual CDocument* GetActiveDocument();

//多文档架构获取激活视图 Active child view maintenance
    CView* GetActiveView() const;           // active view or NULL
    void SetActiveView(CView* pViewNew, BOOL bNotify = TRUE);
        // active view or NULL, bNotify == FALSE if focus should not be set

    // 多文档架构的让某个子框架激活，Active frame (for frames within frames -- MDI)
    virtual CFrameWnd* GetActiveFrame();

    // For customizing the default messages on the status bar
    virtual void GetMessageString(UINT nID, CString&amp; rMessage) const;

    BOOL m_bAutoMenuEnable;
        // TRUE =&gt; menu items without handlers will be disabled

    BOOL IsTracking();

// Operations
    virtual void RecalcLayout(BOOL bNotify = TRUE); //核心排版
    virtual void ActivateFrame(int nCmdShow = -1);
    void InitialUpdateFrame(CDocument* pDoc, BOOL bMakeVisible);
    void SetTitle(LPCTSTR lpszTitle);
    CString GetTitle() const;

    virtual UINT GetTrackingID() { return m_nIDTracking; }

    // set/get menu bar visibility style
    virtual void SetMenuBarVisibility(DWORD dwStyle);
    virtual DWORD GetMenuBarVisibility() const;

    // set/get menu bar visibility state
    virtual BOOL SetMenuBarState(DWORD dwState);
    virtual DWORD GetMenuBarState() const;

    BOOL GetMenuBarInfo(LONG idObject, LONG idItem, PMENUBARINFO pmbi) const;

protected:
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

    friend class CWinApp;
};
</code></pre></div> <p><strong>附录：CFrameWnd::LoadFrame与CreateFrame</strong></p> <div class=highlight><pre><span></span><code>BOOL CFrameWnd::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle,
    CWnd* pParentWnd, CCreateContext* pContext)
{
    CString strFullString;
    if (strFullString.LoadString(nIDResource))
        AfxExtractSubString(m_strTitle, strFullString, 0);    // first sub-string

    VERIFY(AfxDeferRegisterClass(AFX_WNDFRAMEORVIEW_REG));

    // attempt to create the window
    LPCTSTR lpszClass = GetIconWndClass(dwDefaultStyle, nIDResource);
    CString strTitle = m_strTitle;
    if (!Create(lpszClass, strTitle, dwDefaultStyle, rectDefault, 
      pParentWnd, ATL_MAKEINTRESOURCE(nIDResource), 0L, pContext))
    {
        return FALSE;   // will self destruct on failure normally
    }

    // save the default menu handle
    ASSERT(m_hWnd != NULL);
    m_hMenuDefault = m_dwMenuBarState == AFX_MBS_VISIBLE ? ::GetMenu(m_hWnd) : m_hMenu;

    // load accelerator resource
    LoadAccelTable(ATL_MAKEINTRESOURCE(nIDResource));

    if (pContext == NULL)   // send initial update
        SendMessageToDescendants(WM_INITIALUPDATE, 0, 0, TRUE, TRUE);

    return TRUE;
}
</code></pre></div> <h3 id=_26>控件类<a class=headerlink href=#_26 title="Permanent link">*</a></h3> <h4 id=ctreectrl>CTreeCtrl<a class=headerlink href=#ctreectrl title="Permanent link">*</a></h4> <p>CTreeCtrl类的选中消息分析： a)结构体：</p> <div class=highlight><pre><span></span><code>typedef struct tagTVITEMCHANGE {
    NMHDR hdr;
    UINT uChanged;
    HTREEITEM hItem;
    UINT uStateNew;
    UINT uStateOld;
    LPARAM lParam;
} NMTVITEMCHANGE;
</code></pre></div> <p>b)State状态分析：</p> <div class=highlight><pre><span></span><code>TVIS_SELECTED（0x0002）：项被选中。
TVIS_CUT（0x0008）：项被剪切。
TVIS_DROPHILITED（0x0004）：项高亮显示，用于拖放操作。
TVIS_EXPANDED（0x0020）：项展开。
TVIS_BOLD（0x0001）：项以粗体显示。
TVIS_DISABLED（0x0040）：项禁用（灰色显示）。
TVIS_EXPANDEDONCE（0x0200）：项已经展开过一次。
TVIS_EXPANDPARTIAL（0x0400）：项部分展开。
TVIS_OVERLAYMASK（0x0F00）：覆盖层蒙版。
最后你再回头看看CListCtrl类和CTreeCtrl类，里面是啥东西？？？
</code></pre></div> <p>附录1：CListView和CTreeView的原理</p> <p>```// CListView _AFXCVIEW_INLINE CListView::CListView() : CCtrlView(WC_LISTVIEW, AFX_WS_DEFAULT_VIEW) { } _AFXCVIEW_INLINE CListCtrl&amp; CListView::GetListCtrl() const { return <em>(CListCtrl</em>)this; } _AFXCVIEW_INLINE CTreeView::CTreeView() : CCtrlView(WC_TREEVIEW, AFX_WS_DEFAULT_VIEW) { }</p> <p><em>AFXCVIEW_INLINE CTreeCtrl&amp; CTreeView::GetTreeCtrl() const { return <em>(CTreeCtrl</em>)this; } <div class=highlight><pre><span></span><code>附录2：回顾控件类的原理

其实是全都在用**SendMessage**来做事情
</code></pre></div> _AFXCMN_INLINE CTreeCtrl::CTreeCtrl() { } _AFXCMN_INLINE HTREEITEM CTreeCtrl::InsertItem(_In</em> LPTVINSERTSTRUCT lpInsertStruct) { ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct); } <em>AFXCMN_INLINE HTREEITEM CTreeCtrl::InsertItem(_In_z</em> LPCTSTR lpszItem, <em>In</em> int nImage, <em>In</em> int nSelectedImage, <em>In</em> HTREEITEM hParent, <em>In</em> HTREEITEM hInsertAfter) { ASSERT(::IsWindow(m_hWnd)); return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE, lpszItem, nImage, nSelectedImage, 0, 0, 0, hParent, hInsertAfter); } <em>AFXCMN_INLINE HTREEITEM CTreeCtrl::InsertItem(_In_z</em> LPCTSTR lpszItem, <em>In</em> HTREEITEM hParent, <em>In</em> HTREEITEM hInsertAfter) { ASSERT(::IsWindow(m_hWnd)); return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter); } <em>AFXCMN_INLINE BOOL CTreeCtrl::DeleteItem(_In</em> HTREEITEM hItem) { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)hItem); } ······ <div class=highlight><pre><span></span><code>#### CToolBar、CContralBar

**主要属性**
</code></pre></div> // ControlBar styles（理论上包括状态栏、工具栏等）</p> <h1 id=define-cbrs_align_left-0x1000l>define CBRS_ALIGN_LEFT 0x1000L<a class=headerlink href=#define-cbrs_align_left-0x1000l title="Permanent link">*</a></h1> <h1 id=define-cbrs_align_top-0x2000l>define CBRS_ALIGN_TOP 0x2000L<a class=headerlink href=#define-cbrs_align_top-0x2000l title="Permanent link">*</a></h1> <h1 id=define-cbrs_align_right-0x4000l>define CBRS_ALIGN_RIGHT 0x4000L<a class=headerlink href=#define-cbrs_align_right-0x4000l title="Permanent link">*</a></h1> <h1 id=define-cbrs_align_bottom-0x8000l>define CBRS_ALIGN_BOTTOM 0x8000L<a class=headerlink href=#define-cbrs_align_bottom-0x8000l title="Permanent link">*</a></h1> <h1 id=define-cbrs_align_any-0xf000l>define CBRS_ALIGN_ANY 0xF000L//四处都可以停靠<a class=headerlink href=#define-cbrs_align_any-0xf000l title="Permanent link">*</a></h1> <h1 id=define-cbrs_border_left-0x0100l>define CBRS_BORDER_LEFT 0x0100L<a class=headerlink href=#define-cbrs_border_left-0x0100l title="Permanent link">*</a></h1> <h1 id=define-cbrs_border_top-0x0200l>define CBRS_BORDER_TOP 0x0200L<a class=headerlink href=#define-cbrs_border_top-0x0200l title="Permanent link">*</a></h1> <h1 id=define-cbrs_border_right-0x0400l>define CBRS_BORDER_RIGHT 0x0400L<a class=headerlink href=#define-cbrs_border_right-0x0400l title="Permanent link">*</a></h1> <h1 id=define-cbrs_border_bottom-0x0800l>define CBRS_BORDER_BOTTOM 0x0800L<a class=headerlink href=#define-cbrs_border_bottom-0x0800l title="Permanent link">*</a></h1> <h1 id=define-cbrs_border_any-0x0f00l>define CBRS_BORDER_ANY 0x0F00L<a class=headerlink href=#define-cbrs_border_any-0x0f00l title="Permanent link">*</a></h1> <h1 id=define-cbrs_tooltips-0x0010l-n>define CBRS_TOOLTIPS 0x0010L 小字条提示（\n后半）<a class=headerlink href=#define-cbrs_tooltips-0x0010l-n title="Permanent link">*</a></h1> <h1 id=define-cbrs_flyby-0x0020l>define CBRS_FLYBY 0x0020L 状态栏提示的另一半文字<a class=headerlink href=#define-cbrs_flyby-0x0020l title="Permanent link">*</a></h1> <h1 id=define-cbrs_float_multi-0x0040l>define CBRS_FLOAT_MULTI 0x0040L<a class=headerlink href=#define-cbrs_float_multi-0x0040l title="Permanent link">*</a></h1> <h1 id=define-cbrs_border_3d-0x0080l>define CBRS_BORDER_3D 0x0080L<a class=headerlink href=#define-cbrs_border_3d-0x0080l title="Permanent link">*</a></h1> <h1 id=define-cbrs_hide_inplace-0x0008l>define CBRS_HIDE_INPLACE 0x0008L<a class=headerlink href=#define-cbrs_hide_inplace-0x0008l title="Permanent link">*</a></h1> <h1 id=define-cbrs_size_dynamic-0x0004l>define CBRS_SIZE_DYNAMIC 0x0004L 可以拉扯工具栏变形<a class=headerlink href=#define-cbrs_size_dynamic-0x0004l title="Permanent link">*</a></h1> <h1 id=define-cbrs_size_fixed-0x0002l>define CBRS_SIZE_FIXED 0x0002L 固定形状（不可拉扯）<a class=headerlink href=#define-cbrs_size_fixed-0x0002l title="Permanent link">*</a></h1> <h1 id=define-cbrs_floating-0x0001l>define CBRS_FLOATING 0x0001L<a class=headerlink href=#define-cbrs_floating-0x0001l title="Permanent link">*</a></h1> <h1 id=define-cbrs_gripper-0x00400000l>define CBRS_GRIPPER 0x00400000L 掐子（去掉之后就是锁定工具栏的属性） 没有左边的点点，拖不动了<a class=headerlink href=#define-cbrs_gripper-0x00400000l title="Permanent link">*</a></h1> <h1 id=define-cbrs_orient_horz-cbrs_align_topcbrs_align_bottom>define CBRS_ORIENT_HORZ (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)<a class=headerlink href=#define-cbrs_orient_horz-cbrs_align_topcbrs_align_bottom title="Permanent link">*</a></h1> <h1 id=define-cbrs_orient_vert-cbrs_align_leftcbrs_align_right>define CBRS_ORIENT_VERT (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)<a class=headerlink href=#define-cbrs_orient_vert-cbrs_align_leftcbrs_align_right title="Permanent link">*</a></h1> <h1 id=define-cbrs_orient_any-cbrs_orient_horzcbrs_orient_vert>define CBRS_ORIENT_ANY (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)<a class=headerlink href=#define-cbrs_orient_any-cbrs_orient_horzcbrs_orient_vert title="Permanent link">*</a></h1> <h1 id=define-cbrs_all-0x0040ffffl>define CBRS_ALL 0x0040FFFFL<a class=headerlink href=#define-cbrs_all-0x0040ffffl title="Permanent link">*</a></h1> <p>// the CBRS_ style is made up of an alignment style and a draw border style // the alignment styles are mutually exclusive // the draw border styles may be combined</p> <h1 id=define-cbrs_noalign-0x00000000l>define CBRS_NOALIGN 0x00000000L<a class=headerlink href=#define-cbrs_noalign-0x00000000l title="Permanent link">*</a></h1> <h1 id=define-cbrs_left-cbrs_align_leftcbrs_border_right>define CBRS_LEFT (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)<a class=headerlink href=#define-cbrs_left-cbrs_align_leftcbrs_border_right title="Permanent link">*</a></h1> <h1 id=define-cbrs_top-cbrs_align_topcbrs_border_bottom>define CBRS_TOP (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)<a class=headerlink href=#define-cbrs_top-cbrs_align_topcbrs_border_bottom title="Permanent link">*</a></h1> <h1 id=define-cbrs_right-cbrs_align_rightcbrs_border_left>define CBRS_RIGHT (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)<a class=headerlink href=#define-cbrs_right-cbrs_align_rightcbrs_border_left title="Permanent link">*</a></h1> <h1 id=define-cbrs_bottom-cbrs_align_bottomcbrs_border_top>define CBRS_BOTTOM (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)<a class=headerlink href=#define-cbrs_bottom-cbrs_align_bottomcbrs_border_top title="Permanent link">*</a></h1> <p><div class=highlight><pre><span></span><code>## MFC六大关键技术

1、MFC Initialization —— MFC程序的初始化过程

2、Message Mapping —— 消息映射

3、Message Routing —— 消息传递（路由）

4、RTTI（Runtime Type Identification）—— 运行时类型识别

5、Dynamic Creation —— 动态创建

6、Persistence ——永久保存（串行化、序列化）

### MFC程序的初始化过程

参见：CWinApp::InitInstance的虚函数，MFC内部接管WinMain平台启动初始化之后再调用InitInstance。
开发者需要创建CWinApp的派生类，并且在全局区定义派生类的全局对象，最后在派生类礼重写InitInstance虚函数。

### 消息传递（路由）

主要在框架与视图架构里，把框架收到的菜单和工具栏消息分发到各个视图类。
</code></pre></div> BOOL CMainFrame::OnCmdMsg(UINT nID...) if (m_pView &amp;&amp; m_pView-&gt;OnCmdMsg(nID, nCode, pExtra, pHandlerInfo)) return TRUE; <div class=highlight><pre><span></span><code>### RTTI  运行时类型识别

核心的作用是任何MFC的类（CObject派生）都能够获取到类型信息。
而且能知道你的派生类是谁，甚至获取到整个派生树分枝的名字。

    auto pInfo = obj.GetRuntimeClass();
    while (pInfo)
    {
    AfxMessageBox(CString(_T(&quot;你是：&quot;)) + pInfo-&gt;m_lpszClassName);
    pInfo = pInfo-&gt;m_pBaseClass;//pNext;
    }

参见：RUNTIME_CLASS宏以及每个MFC类的信息管理：
</code></pre></div> DECLARE_DYNAMIC(CMainFrame) IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd) <div class=highlight><pre><span></span><code>RTTI运行时识别类型，靠的就是
</code></pre></div> BOOL CObject::IsKindOf(const CRuntimeClass* pClass) const;//用IsKindOf进行类型的识别。 CRuntimeClass* pClassThis = GetRuntimeClass(); <div class=highlight><pre><span></span><code>#### RTTI

a)RTTI(Runtime Type Identification)是“运行时类型识别”的意思。
b)现有MFC的这项发明，后来RTTI被引入C++语言。
c)但凡是CObject派生的所有MFC类的对象都可以来探测一下他的派生来源。
d)参见CObject::IsKindOf( const CRuntimeClass* pClass  ) const;

#### RUNTIME_CLASS运行时类的原理

类中用`DECLARE_DYNAMIC(CMainFrame)`定义户籍信息
</code></pre></div> DECLARE_DYNAMIC(CMainFrame);//展开后的样子：（全局区的户籍信息）</p> <p>static const CRuntimeClass classCMainFrame; //定义了一个CRuntimeClass类型的镜头盖对象，每个类独一份 virtual CRuntimeClass* GetRuntimeClass() const; //展开 <div class=highlight><pre><span></span><code>
</code></pre></div></p> <h1 id=define-_runtime_classclass_name-cruntimeclassclass_nameclassclass_name>define _RUNTIME_CLASS(class_name) ((CRuntimeClass*)(&amp;class_name::class##class_name))<a class=headerlink href=#define-_runtime_classclass_name-cruntimeclassclass_nameclassclass_name title="Permanent link">*</a></h1> <p>//既是((CRuntimeClass*)(&amp;CMainFrame::classCMainFrame)) <div class=highlight><pre><span></span><code>定义户籍信息后，在cpp文件中形成一个类似树状的链表，其实就是对形成的户籍本进行赋值

用该语句进行`IMPLEMENT_DYNAMIC(class_name, base_class_name) `一般在cpp文件中执行
</code></pre></div> //#define IMPLEMENT_DYNAMIC(class_name, base_class_name) // IMPLEMENT_RUNTIMECLASS(CMainFrame, CFrameWnd, 0xFFFF, NULL, NULL)</p> <p>//展开即：</p> <p>AFX_COMDAT const CRuntimeClass CMainFrame::classCMainFrame = { "CMainFrame", sizeof(class CMainFrame), 0xFFFF, NULL, RUNTIME_CLASS(CFrameWnd), NULL, NULL }; CRuntimeClass* CMainFrame::GetRuntimeClass() const { return RUNTIME_CLASS(CMainFrame); } //可以理解为对结构体成员进行赋值。其中 RUNTIME_CLASS(CFrameWnd)就是对CRuntimeClass::m_pBaseClass赋值，形成链表。 <div class=highlight><pre><span></span><code>CRuntimeClass类：
</code></pre></div> struct CRuntimeClass { // Attributes LPCSTR m_lpszClassName; int m_nObjectSize; UINT m_wSchema; // schema number of the loaded class CObject* (PASCAL* m_pfnCreateObject)(); // NULL =&gt; abstract class</p> <h1 id=ifdef-_afxdll>ifdef _AFXDLL<a class=headerlink href=#ifdef-_afxdll title="Permanent link">*</a></h1> <div class=codehilite><table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre><span class=normal>1</span></pre></div></td><td class=code><div><pre><span></span><code>CRuntimeClass* (PASCAL* m_pfnGetBaseClass)();
</code></pre></div></td></tr></table></div> <h1 id=else>else<a class=headerlink href=#else title="Permanent link">*</a></h1> <div class=codehilite><table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre><span class=normal>1</span></pre></div></td><td class=code><div><pre><span></span><code>CRuntimeClass* m_pBaseClass; //
</code></pre></div></td></tr></table></div> <h1 id=endif>endif<a class=headerlink href=#endif title="Permanent link">*</a></h1> <p>// Operations CObject* CreateObject(); BOOL IsDerivedFrom(const CRuntimeClass* pBaseClass) const; 。。。 <div class=highlight><pre><span></span><code>IsKindOf()内部有一个循环，可以循环追踪。



## Tips

### 待定

#### 获取Bitmap的宽高 
</code></pre></div> CSize CBitmap::GetBitmapDimension();//获取位图的Size,但是在恢复Rgn的时候使用会不好使。 CSize ss = dc.GetCurrentBitmap()-&gt;GetBitmapDimension();//获得的值竟然是空的。 <div class=highlight><pre><span></span><code>#### 图片加载.bmp .ico .cur

都可以用LoadImage加载

例如Bitmap

```c++
HBITMAP hBitmap = (HBITMAP)LoadImage(NULL,sFile, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);、
</code></pre></div></p> <h4 id=hdc>四大HDC句柄<a class=headerlink href=#hdc title="Permanent link">*</a></h4> <ol> <li>标准绘图句柄：BeginPaint和EndPaint</li> <li>临时客户区句柄：GetDC和ReleaseDC</li> <li>非客户区绘图句柄：GetWindowDC和ReleaseDC</li> <li>内存绘图句柄：CreateCompatibleDC 和 DeleteDC</li> </ol> <h4 id=_27>图片不能加载<a class=headerlink href=#_27 title="Permanent link">*</a></h4> <ul> <li>路径问题，在Debug中双击exe运行时，相对路径以exe为基准，因此检索不到res文件夹，不能显示图片，应放在同一目录。</li> </ul> <h4 id=setwindowrgn>SetWindowRgn失效期<a class=headerlink href=#setwindowrgn title="Permanent link">*</a></h4> <p>SetWindowRgn(CRgn rgn, TRUE); rgn 在使用后会被废掉，若使用已保存好的Rgn数组，则应当rgn.CopyRgn出来后再使用。</p> <h4 id=vc60-pchh>VC6.0 pch.h<a class=headerlink href=#vc60-pchh title="Permanent link">*</a></h4> <p>VC6.0中 pch.h文件时StdAfx.h</p> <h4 id=_28>填充背景色函数<a class=headerlink href=#_28 title="Permanent link">*</a></h4> <div class=highlight><pre><span></span><code>pDC-&gt;FillSolidRect(rect, GetSysColor(COLOR_INFOBK));
</code></pre></div> <h4 id=gdi_1>调用系统GDI的函数<a class=headerlink href=#gdi_1 title="Permanent link">*</a></h4> <div class=highlight><pre><span></span><code>LoadStandardCursor();
LoadStandardIcon();
GetStockObject();
//等。
</code></pre></div> <h4 id=cchildview>CChildView<a class=headerlink href=#cchildview title="Permanent link">*</a></h4> <p>框架视图中这个类往往没啥用，可以干掉。</p> <h4 id=clistview_1>CListView初始化时不显示字段与窗格<a class=headerlink href=#clistview_1 title="Permanent link">*</a></h4> <div class=highlight><pre><span></span><code>list.ModifyStyle(0, LVS_REPORT);//加上这条语句就好了
</code></pre></div> <p>个人感觉是View视图控件和默认预设的控件没有什么本质区别。</p> <p>在使用对话框创建控件时还需要进行预设属性，对属性不够明晰了解是可以考虑使用对话框对属性进行探究。</p> <p>这里LVS_REPORT是在对话框资源窗口就修改完成了，在View中还需要进行一下自己的设置。</p> <h4 id=_29>随笔记录<a class=headerlink href=#_29 title="Permanent link">*</a></h4> <ol> <li>CS架构的客户端不需要链接数据库，因为数据是通过网络协议发送和接收的。</li> </ol> <h4 id=alt>按住alt加鼠标左键可以实现方框拖选。<a class=headerlink href=#alt title="Permanent link">*</a></h4> <h4 id=app>构造函数时搞App对象<a class=headerlink href=#app title="Permanent link">*</a></h4> <h4 id=qq>屏幕绘制、QQ截图<a class=headerlink href=#qq title="Permanent link">*</a></h4> <p>他们都不是真实的截图，而是搞出了一个全屏的截图窗口，进行截取与绘制。</p> <h4 id=ondraw>实际开发中，用重写OnDraw虚函数进行绘制<a class=headerlink href=#ondraw title="Permanent link">*</a></h4> <p>因为重写OnPaint基类的东西就不能用了。</p> <h4 id=_30>消息映射精简<a class=headerlink href=#_30 title="Permanent link">*</a></h4> <p>例如绘图项目中，用到了7个消息映射，每个映射仅有一行代码，此时可以用这个宏进行精简。</p> <p>研究区间命令管理，把7套命令和状态管理函数合并成1套。</p> <p>范围精简：</p> <div class=highlight><pre><span></span><code>#define ON_COMMAND_RANGE(id, idLast, memberFxn) 
#define ON_UPDATE_COMMAND_UI_RANGE(id, idLast, memberFxn) 
</code></pre></div> <p>```\ BEGIN_MESSAGE_MAP(CMainView, CView) ON_COMMAND_RANGE(ID_DRAW_DRAG, ID_DRAW_RRECT, OnDrawCommad) ON_UPDATE_COMMAND_UI_RANGE(ID_DRAW_DRAG, ID_DRAW_RRECT, OnUpdateDrawUI) END_MESSAGE_MAP()</p> <p>void CMainView::OnDrawCommad(UINT nID) {//7个函数合成一个，非常的方便 m_nIndex = nID; } void CMainView::OnUpdateDrawUI(CCmdUI* pCmdUI) { pCmdUI-&gt;SetCheck(m_nIndex == pCmdUI-&gt;m_nID); } <div class=highlight><pre><span></span><code>## 项目记录  

### CBitmapButton三态按钮开发

#### 鼠标离开控件切换Bitmap

鼠标在离开控件的瞬间，WM_MOUSEMOVE消息会失效，所以这里不能通过PtInRect判断。

此处有两种方法：

1. 利用WM_MOUSELEAVE消息：需要TrackMouseEvent来追踪。

2. SetCapture和ReleaseCapture：设置捕捉。

WM_MOUSELEAVE消息：
</code></pre></div> void CButtonYXX::OnMouseMove(UINT nFlags, CPoint point) {//在代码中调用TrackMouseEvent(&amp;tme);这样在离开时就会发送一条WM_MOUSELEAVE消息。 if (!m_track) { TRACKMOUSEEVENT tme; tme.cbSize = sizeof(TRACKMOUSEEVENT); tme.dwFlags = TME_LEAVE; tme.hwndTrack = m_hWnd; TrackMouseEvent(&amp;tme);</p> <div class=codehilite><table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span></pre></div></td><td class=code><div><pre><span></span><code>    m_track = TRUE;
    Invalidate(FALSE);
}
CWnd::OnMouseMove(nFlags, point);
</code></pre></div></td></tr></table></div> <p>} void CButtonYXX::OnMouseLeave() { m_track = FALSE; Invalidate(FALSE); CWnd::OnMouseLeave(); } <code>SetCapture</code> void CButtonYXX::OnMouseMove(UINT nFlags, CPoint point) {//进入onmousemove函数即是在控件中，若m_track==0，说明是从外进来，则SetCapture。 CRect rect; GetClientRect(&amp;rect); if (!m_track) { SetCapture(); m_track = TRUE; Invalidate(FALSE); } if (!rect.PtInRect(point)) {//若离开，此时因为SetCapture函数，在函数中，但是点不在矩形中，所以用PtInRect判断 //若不在矩形内，又在MOUSEMOVE函数内，是从控件中离开，所以ReleaseCapture()。 ReleaseCapture(); m_track = FALSE; Invalidate(FALSE); } CWnd::OnMouseMove(nFlags, point); } ``` </p> <h4 id=bitmap_1>bitmap三态切换代码示意<a class=headerlink href=#bitmap_1 title="Permanent link">*</a></h4> <p>个人感觉要点就是，选择nID来决定贴图，用m_track、m_select、和m_Outdown来选择显示什么图 <code>void CButtonYXX::OnPaint()//作为主绘图，用m_track和nID作为判断，最后选择到底显示绘制什么图片。 { CPaintDC dc(this); // device context for painting CRect rect; GetClientRect(rect); //用GetClient代替获取BITMAP结构体信息以降低开支。 int nID = BT_NORMAL; if(m_track) nID = BT_FOCUS; if(m_select) nID = BT_SELECT; if(m_Outdown) nID = BT_FOCUS; //这里的判断优先级有强弱之分的。 dc.BitBlt(0, 0, rect.Width(), rect.Height(), &amp;m_dc[nID], 0, 0, SRCCOPY); }</code> <code>void CButtonYXX::OnMouseMove(UINT nFlags, CPoint point) {//核心算法 static BOOL ifSelRefresh = FALSE;//设置状态 CRect rect; GetClientRect(&amp;rect); if (ifSelRefresh == TRUE) {//利用静态变量判断，使得从页面外回来并松开点击时可以刷新一次。 m_Outdown = FALSE; Invalidate(FALSE); } if (!m_track) {//进入空间时，赋值m_track并刷新一次。 SetCapture(); m_track = TRUE; if(!m_select)//有m_select就不刷新这个了，防止冲突，这个没啥用 Invalidate(FALSE); } if (!rect.PtInRect(point)) {//从矩形内移到控件外触发， if (nFlags == MK_LBUTTON ) {//按住左键离开 if (!m_Outdown) {//使m_Outdown为TRUE，并刷新一次。 m_Outdown = TRUE; ifSelRefresh = TRUE; Invalidate(FALSE); } } else {//离开举行外并没按住左键，一切归0 m_select = FALSE; m_track = FALSE; m_Outdown = FALSE; ReleaseCapture(); Invalidate(FALSE); } } CWnd::OnMouseMove(nFlags, point); } void CButtonYXX::OnMouseLeave() { //m_track = FALSE; //Invalidate(FALSE); CWnd::OnMouseLeave(); } void CButtonYXX::OnLButtonDown(UINT nFlags, CPoint point) { //单击强制触发刷新一次。 m_select = TRUE; Invalidate(FALSE); CWnd::OnLButtonDown(nFlags, point); } void CButtonYXX::OnLButtonUp(UINT nFlags, CPoint point) {松开则一切归0, CRect rect; GetClientRect(&amp;rect); ReleaseCapture(); if (rect.PtInRect(point)) { //执行代码 AfxMessageBox(_T("hh")); } m_select = FALSE; m_track = FALSE; m_Outdown = FALSE; Invalidate(FALSE); CWnd::OnLButtonUp(nFlags, point); }</code> </p> <h3 id=cmemorydc>封装CMemoryDC类<a class=headerlink href=#cmemorydc title="Permanent link">*</a></h3> <p>利用CMemoryDC类，可以在CDC的基础上添加功能。 如 挖去背景、加载位图到CDC </p> <h4 id=cmemorydc_1>CMemoryDC类<a class=headerlink href=#cmemorydc_1 title="Permanent link">*</a></h4> <p>```</p> <h1 id=include>include <afxwin.h><a class=headerlink href=#include title="Permanent link">*</a></h1> <p>class CMemoryDC :public CDC { public: CMemoryDC():m_size{} {</p> <div class=codehilite><table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span>
<span class=normal>54</span>
<span class=normal>55</span></pre></div></td><td class=code><div><pre><span></span><code>}
CMemoryDC(UINT nIDResource)
{
    LoadBitmap(nIDResource);
}
~CMemoryDC()
{

}
void MakeRgn(CRgn&amp; rResource, COLORREF col)
{
    if(!rResource.GetSafeHandle())
        rResource.CreateRectRgn(0, 0, 0, 0);
    for (int i = 0; i &lt; m_size.cy; ++i)
    {
        for (int j = 0; j &lt; m_size.cx; ++j)
        {
            if (GetPixel(j, i) != col)
            {
                CRgn rTemp;
                rTemp.CreateRectRgn(j, i, j + 1, i + 1);//1x1 像素,这里的ij有一点颠倒
                rResource.CombineRgn(&amp;rResource, &amp;rTemp, RGN_OR);
            }
        }
    }
}

BOOL LoadBitmap(UINT nIDResource,CDC* pDC = NULL)//后面这个参数不知道干嘛的
{
    if (!CreateCompatibleDC(NULL))
        return FALSE;//创建DC，这个比较快，先判断
    CBitmap bmp;
    if (!bmp.LoadBitmap(nIDResource))
    {
        DeleteDC();//防止之前创建了DC但是没成功加载图片
        return FALSE;//LoadBitmap比较慢，后判断
    }
    BITMAP bm;
    bmp.GetBitmap(&amp;bm);
    SelectObject(&amp;bmp);
    m_size.SetSize(bm.bmWidth, bm.bmHeight);
    return TRUE;
}
CSize GetSize()const
{
    return m_size;
}
int GetWidth()const
{
    return m_size.cx;
}
int GetHeight()const
{
    return m_size.cy;
}
</code></pre></div></td></tr></table></div> <p>protected: CSize m_size; // CDC m_dc;//不用这个，因为基类就有 }; ``` </p> <h3 id=rgn_2>Rgn动图<a class=headerlink href=#rgn_2 title="Permanent link">*</a></h3> <p>类中成员。 <code>protected: CPoint m_pos; int m_x, m_y; enum {STM_FLYMOVE=8888}; CMemoryDC m_dcBack; CMemoryDC m_dcFlys[7]; CRgn m_rFlys[7];//加载的时候放到数组中就可以节省切换时候的内存开销，是一个很好的方法。 int m_nFlyIndex;//切换动画 // 构造</code> </p> <h3 id=cviewcs>CView实现CS架构管理系统<a class=headerlink href=#cviewcs title="Permanent link">*</a></h3> <p>利用CListView做主视图 - 新建项目 - 产出CChileView相关 - 自CListView派生CMainView类 - pch.h包含CListView的头文件afxcview.h - 在CMainFrame::OnCreate中创建视图 <code>c++ CCreateContext cc;//创建视图 cc.m_pNewViewClass = RUNTIME_CLASS(CMainView)); CreateView(&amp;cc);</code></p> <ul> <li>虚函数<code>OnInitialUpdate()</code>中</li> </ul> <div class=highlight><pre><span></span><code><span class=n>CListCtrl</span><span class=o>&amp;</span><span class=w> </span><span class=n>list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetListCtrl</span><span class=p>();</span>
<span class=c1>//list.ModifyStyle(0, LVS_REPORT);</span>
<span class=n>list</span><span class=p>.</span><span class=n>InsertColumn</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>_T</span><span class=p>(</span><span class=s>&quot;工号&quot;</span><span class=p>),</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>180</span><span class=p>);</span>
<span class=n>list</span><span class=p>.</span><span class=n>InsertColumn</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=n>_T</span><span class=p>(</span><span class=s>&quot;姓名&quot;</span><span class=p>),</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>180</span><span class=p>);</span>
<span class=n>list</span><span class=p>.</span><span class=n>InsertColumn</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=n>_T</span><span class=p>(</span><span class=s>&quot;工资&quot;</span><span class=p>),</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>180</span><span class=p>);</span>
<span class=n>list</span><span class=p>.</span><span class=n>InsertColumn</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=n>_T</span><span class=p>(</span><span class=s>&quot;入职日期&quot;</span><span class=p>),</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>180</span><span class=p>);</span>
<span class=n>list</span><span class=p>.</span><span class=n>SetExtendedStyle</span><span class=p>(</span><span class=n>LVS_EX_FULLROWSELECT</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>LVS_EX_GRIDLINES</span><span class=p>);</span>
</code></pre></div> <h3 id=drawyxx>DrawYxx 绘图项目<a class=headerlink href=#drawyxx title="Permanent link">*</a></h3> <p>利用多文档视图架构实现。</p> <ul> <li> <p>制造右侧停靠的窗口，编辑绘图的界面，绘制与修改ToolBar，并设置调配ToolBar属性。</p> </li> <li> <p>创建工具栏属性的映射函数</p> </li> <li>制作点击切换工具栏选中显示。</li> </ul> <h4 id=ccontralbartoolbar>CContralBar切换、ToolBar单击切换选中<a class=headerlink href=#ccontralbartoolbar title="Permanent link">*</a></h4> <p>做法是和UI有关系，一个ToolBarID，在类视图中可以建立两个映射函数，一个是COMMAND，一个是下面的ui函数。</p> <p>用</p> <div class=highlight><pre><span></span><code>    //CMainView类中，用m_nIndex作为记录，类似于蝴蝶的切换。
    int m_nIndex{ ID_DRAW_DRAG };//初始化ID为第一个，一共有七个。
</code></pre></div> <div class=highlight><pre><span></span><code>void CMainView::OnDrawDrag()
{//COMMAND 用于给m_nIndex赋值和判断
    m_nIndex = ID_DRAW_DRAG;
}
void CMainView::OnDrawEllipse()
{
    m_nIndex = ID_DRAW_ELLIPSE;
}
</code></pre></div> <div class=highlight><pre><span></span><code>void CMainView::OnUpdateDrawDrag(CCmdUI* pCmdUI)
{//利用UI进行修改，m_nIndex == pCmdUI-&gt;m_nID用于改变FALSE还是TRUE。
    pCmdUI-&gt;SetCheck(m_nIndex == pCmdUI-&gt;m_nID);
}
void CMainView::OnUpdateDrawEllipse(CCmdUI* pCmdUI)
{
    pCmdUI-&gt;SetCheck(m_nIndex == pCmdUI-&gt;m_nID);
}
</code></pre></div> <h4 id=slayer>SLayer纯虚架构<a class=headerlink href=#slayer title="Permanent link">*</a></h4> <p>SLayer 作为基类，CLine、CPencil等类都由此派生，记录和调用都归派生类</p> <div class=highlight><pre><span></span><code>struct SLayer
{//做成纯虚函数，貌似纯虚了就不用写定义了。
    virtual void OnMouseMove(UINT nFlags, CPoint point) = 0;
    virtual void OnLButtonUp(UINT nFlags, CPoint point) = 0;
    virtual void OnLButtonDown(UINT nFlags, CPoint point) = 0;
    virtual void OnDraw(CDC* pDC) = 0;
};
</code></pre></div> <p>例如CLine</p> <div class=highlight><pre><span></span><code>class CLine : public SLayer
{//核心就是两个点
    CPoint m_ps, m_pe;//Start  End;
    virtual void OnMouseMove(UINT nFlags, CPoint point);
    virtual void OnLButtonUp(UINT nFlags, CPoint point);//记录m_pe
    virtual void OnLButtonDown(UINT nFlags, CPoint point);//记录m_ps
    virtual void OnDraw(CDC* pDC);//用MoveTo   LineTo绘制
};
</code></pre></div> <p>在CMainView中：</p> <div class=highlight><pre><span></span><code>void CMainView::OnLButtonDown(UINT nFlags, CPoint point)
{
    SLayer* pLayer = nullptr;
    switch (m_nIndex)
    {
    case ID_DRAW_LINE:
        pLayer = new CLine;
        break;
    case ID_DRAW_PENCIL:
        pLayer = new CLine;
        break;
    }
    if (pLayer != nullptr)
    {//虚函数架构在这里就十分的方便了。
        pLayer-&gt;OnLButtonDown(nFlags,point);
        m_ls.Add(pLayer);
    }
    CView::OnLButtonDown(nFlags, point);
}
void CMainView::OnLButtonUp(UINT nFlags, CPoint point)
{
    int nCount = m_ls.GetCount();
    if (nCount &lt; 1)
        return;
    m_ls[--nCount]-&gt;OnLButtonUp(nFlags, point);//调用各自类对象的函数记录核心数据
    Invalidate();
    CView::OnLButtonUp(nFlags, point);
}
void CMainView::OnDraw(CDC* pDC)
{
    int nCount = m_ls.GetCount();
    for (int i = 0; i &lt; nCount; ++i)
    {
        m_ls[i]-&gt;OnDraw(pDC);//调用各自的类进行绘制，十分节省代码量
    }
}
</code></pre></div> <h4 id=_31><a class=headerlink href=#_31 title="Permanent link">*</a></h4> <hr> <div class=md-source-file> <small> 最后更新: <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">November 11, 2023</span> </small> </div> </article> </div> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2020 - 2021 jsyPrajna </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> <div class=md-social> <a href=https://notes.caijiqhx.top/ target=_blank rel=noopener title="cjqxh on github" class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "search.suggest", "search.highlight", "search.share", "content.code.annotate"], "search": "../../assets/javascripts/workers/search.a264c092.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script> <script src=../../assets/javascripts/bundle.726fbb30.min.js></script> <script src=../../static/js/bundle.525231ca.min.js></script> <script src=https://cdnjs.loli.net/ajax/libs/pangu/3.3.0/pangu.min.js></script> <script src=../../static/js/extra.js></script> <script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>